%{
  #include "part3_helpers.hpp"

  #include <string>
  #include <vector>
  #include <unordered_map>
  #include <algorithm>
  #include <sstream>
  #include <cstdlib>

  using std::string;
  using std::vector;

  extern int yylex(void);
  void yyerror(const char*);

  // -----------------------------
  // Reserved registers (convention)
  // -----------------------------
  static constexpr int I_RA   = 0;   // return address (JLINK sets I0):contentReference[oaicite:5]{index=5}
  static constexpr int I_FP   = 1;   // frame pointer
  static constexpr int I_SP   = 2;   // stack pointer
  static constexpr int I_RET  = 3;   // return value int
  static constexpr int I_TMP  = 4;   // scratch
  static constexpr int I_ADDR = 5;   // scratch address computation

  static constexpr int F_FP   = 1;   // float copy of FP (for LOADF/STORF base)
  static constexpr int F_SP   = 2;   // float copy of SP (for LOADF/STORF base)
  static constexpr int F_RET  = 3;   // return value float
  static constexpr int F_BASE = 4;   // scratch base for restoring float temps
  static constexpr int F_ADDR = 5;   // scratch address computation for float mem ops

  static constexpr int INT_TMP_BASE   = 11;
  static constexpr int FLOAT_TMP_BASE = 10;

  static constexpr int FRAME_HDR_SIZE = 8;      // [oldFP @ +0] [savedRA @ +4]
  static constexpr int INVALID_JLINK_TARGET = 999999; // recommended invalid placeholder:contentReference[oaicite:6]{index=6}

  static inline string Ireg(int r){ return "I" + std::to_string(r); }
  static inline string Freg(int r){ return "F" + std::to_string(r); }

  // -----------------------------
  // Symbol tables (scoped)
  // -----------------------------
  static vector<std::unordered_map<string, VarBinding>> g_scopes;

  // Per-function state
  static string g_currFunc;
  static Type   g_currRetType = Type::VOID;

  static int g_nextLocalOffset = FRAME_HDR_SIZE; // locals start after header

  static int g_nextIntReg = INT_TMP_BASE;
  static int g_nextFloatReg = FLOAT_TMP_BASE;

  static vector<int> g_returnJumps; // UJUMP lines for return statements
  static int g_localAllocLine = -1;

  // -----------------------------
  // Helpers
  // -----------------------------
  static void resetTemps() {
    g_nextIntReg = INT_TMP_BASE;
    g_nextFloatReg = FLOAT_TMP_BASE;
  }

  static int allocIntReg() {
    return g_nextIntReg++;
  }
  static int allocFloatReg() {
    return g_nextFloatReg++;
  }

  static void pushScope() {
    g_scopes.push_back({});
  }
  static void popScope() {
    if (!g_scopes.empty()) g_scopes.pop_back();
  }

  static VarBinding* lookupVar(const string& name) {
    for (int i = (int)g_scopes.size() - 1; i >= 0; --i) {
      auto it = g_scopes[i].find(name);
      if (it != g_scopes[i].end()) return &it->second;
    }
    return nullptr;
  }

  static void declareVar(const string& name, Type t, int offset) {
    if (t == Type::VOID) {
      reportSemanticErrorAndExit("cannot declare variable/parameter of type void", yylineno);
    }
    if (g_scopes.empty()) pushScope();
    auto& top = g_scopes.back();
    if (top.find(name) != top.end()) {
      reportSemanticErrorAndExit("redeclaration of variable " + name, yylineno);
    }
    top[name] = VarBinding{t, offset, (int)g_scopes.size()};
  }

  // Keep F_FP and F_SP correct (calls may clobber ANY reg):contentReference[oaicite:7]{index=7}
  static void syncFloatBases() {
    g_code.emit("CITOF " + Freg(F_FP) + " " + Ireg(I_FP));
    g_code.emit("CITOF " + Freg(F_SP) + " " + Ireg(I_SP));
  }
  static void syncFloatSP() {
    g_code.emit("CITOF " + Freg(F_SP) + " " + Ireg(I_SP));
  }
  static void syncFloatFP() {
    g_code.emit("CITOF " + Freg(F_FP) + " " + Ireg(I_FP));
  }

  // Memory access that works for:
  // - locals (offset >= 0): base FP directly
  // - params (offset < 0): compute address in I_ADDR to avoid negative immediates
  static void emitLoadVarInt(int destI, int offsetFromFP) {
    if (offsetFromFP >= 0) {
      g_code.emit("LOADI " + Ireg(destI) + " " + Ireg(I_FP) + " " + std::to_string(offsetFromFP));
    } else {
      int absOff = -offsetFromFP;
      g_code.emit("SUBTI " + Ireg(I_ADDR) + " " + Ireg(I_FP) + " " + std::to_string(absOff));
      g_code.emit("LOADI " + Ireg(destI) + " " + Ireg(I_ADDR) + " 0");
    }
  }

  static void emitStoreVarInt(int srcI, int offsetFromFP) {
    if (offsetFromFP >= 0) {
      g_code.emit("STORI " + Ireg(srcI) + " " + Ireg(I_FP) + " " + std::to_string(offsetFromFP));
    } else {
      int absOff = -offsetFromFP;
      g_code.emit("SUBTI " + Ireg(I_ADDR) + " " + Ireg(I_FP) + " " + std::to_string(absOff));
      g_code.emit("STORI " + Ireg(srcI) + " " + Ireg(I_ADDR) + " 0");
    }
  }

  static void emitLoadVarFloat(int destF, int offsetFromFP) {
    if (offsetFromFP >= 0) {
      syncFloatFP();
      g_code.emit("LOADF " + Freg(destF) + " " + Freg(F_FP) + " " + std::to_string(offsetFromFP));
    } else {
      int absOff = -offsetFromFP;
      g_code.emit("SUBTI " + Ireg(I_ADDR) + " " + Ireg(I_FP) + " " + std::to_string(absOff));
      g_code.emit("CITOF " + Freg(F_ADDR) + " " + Ireg(I_ADDR));
      g_code.emit("LOADF " + Freg(destF) + " " + Freg(F_ADDR) + " 0");
    }
  }

  static void emitStoreVarFloat(int srcF, int offsetFromFP) {
    if (offsetFromFP >= 0) {
      syncFloatFP();
      g_code.emit("STORF " + Freg(srcF) + " " + Freg(F_FP) + " " + std::to_string(offsetFromFP));
    } else {
      int absOff = -offsetFromFP;
      g_code.emit("SUBTI " + Ireg(I_ADDR) + " " + Ireg(I_FP) + " " + std::to_string(absOff));
      g_code.emit("CITOF " + Freg(F_ADDR) + " " + Ireg(I_ADDR));
      g_code.emit("STORF " + Freg(srcF) + " " + Freg(F_ADDR) + " 0");
    }
  }

  static bool sameSignature(const FunctionInfo& a, const FunctionInfo& b) {
    if (a.retType != b.retType) return false;
    if (a.paramTypes.size() != b.paramTypes.size()) return false;
    for (size_t i = 0; i < a.paramTypes.size(); ++i) {
      if (a.paramTypes[i] != b.paramTypes[i]) return false;
    }
    if (a.paramNames.size() != b.paramNames.size()) return false;
    for (size_t i = 0; i < a.paramNames.size(); ++i) {
      if (a.paramNames[i] != b.paramNames[i]) return false;
    }
    return true;
  }

  static void declareFunction(const string& name,
                              Type retType,
                              const vector<Type>& pTypes,
                              const vector<string>& pNames,
                              bool isDefinition) {
    // params may not be void
    for (Type t : pTypes) {
      if (t == Type::VOID) {
        reportSemanticErrorAndExit("parameter cannot be void in function " + name, yylineno);
      }
    }

    FunctionInfo sig;
    sig.retType = retType;
    sig.paramTypes = pTypes;
    sig.paramNames = pNames;

    auto it = g_functions.find(name);
    if (it == g_functions.end()) {
      sig.isDefined = isDefinition;
      g_functions[name] = sig;
      return;
    }

    // function already known: signature must match
    if (!sameSignature(it->second, sig)) {
      reportSemanticErrorAndExit("conflicting function declaration/definition for " + name, yylineno);
    }

    if (isDefinition) {
      if (it->second.isDefined) {
        reportSemanticErrorAndExit("redefinition of function " + name, yylineno);
      }
      it->second.isDefined = true;
    }
  }

  static void beginFunction(const string& name) {
    g_currFunc = name;
    g_currRetType = g_functions[name].retType;

    // Patch any prior calls in this same module to this function
    int startLine = g_code.nextQuad();
    g_functions[name].startLineImplementation = startLine;
    if (!g_functions[name].unresolvedCallLines.empty()) {
      g_code.backpatch(g_functions[name].unresolvedCallLines, startLine);
      g_functions[name].unresolvedCallLines.clear();
    }

    // New scope for function body
    g_scopes.clear();
    pushScope();

    // Insert parameters into scope with negative offsets:
    // param i (0-based): FP - 4*(n-i)
    int n = (int)g_functions[name].paramTypes.size();
    for (int i = 0; i < n; ++i) {
      int off = -4 * (n - i);
      declareVar(g_functions[name].paramNames[i], g_functions[name].paramTypes[i], off);
    }

    // Reset locals + temp regs
    g_nextLocalOffset = FRAME_HDR_SIZE;
    resetTemps();
    g_returnJumps.clear();

    // Prologue:
    // I4 = oldFP
    // FP = SP
    // [FP+0] = oldFP
    // [FP+4] = savedRA
    // SP += frameSize  (patched later)
    g_code.emit("COPYI " + Ireg(I_TMP) + " " + Ireg(I_FP));
    g_code.emit("COPYI " + Ireg(I_FP) + " " + Ireg(I_SP));
    g_code.emit("STORI " + Ireg(I_TMP) + " " + Ireg(I_FP) + " 0");
    g_code.emit("STORI " + Ireg(I_RA)  + " " + Ireg(I_FP) + " 4");

    g_localAllocLine = g_code.nextQuad();
    g_code.emit("ADD2I " + Ireg(I_SP) + " " + Ireg(I_SP) + " "); // backpatch with frame size

    // Prepare float FP/SP helpers for LOADF/STORF base constraints:contentReference[oaicite:8]{index=8}
    syncFloatBases();
  }

  static void endFunction(const vector<int>& blkNextList) {
    int frameSize = g_nextLocalOffset;

    // Patch local allocation
    g_code.backpatch({g_localAllocLine}, frameSize);

    // Epilogue start label
    int epilogueLine = g_code.nextQuad();

    // Patch:
    // - fallthrough jumps from statement list
    // - all return jumps
    if (!blkNextList.empty()) g_code.backpatch(blkNextList, epilogueLine);
    if (!g_returnJumps.empty()) g_code.backpatch(g_returnJumps, epilogueLine);

    // Epilogue:
    // SP = FP
    // I0 = Mem[FP+4]
    // I4 = Mem[FP+0] ; oldFP
    // FP = I4
    // RETRN
    g_code.emit("COPYI " + Ireg(I_SP) + " " + Ireg(I_FP));
    g_code.emit("LOADI " + Ireg(I_RA) + " " + Ireg(I_FP) + " 4");
    g_code.emit("LOADI " + Ireg(I_TMP) + " " + Ireg(I_FP) + " 0");
    g_code.emit("COPYI " + Ireg(I_FP) + " " + Ireg(I_TMP));
    g_code.emit("RETRN");

    // pop function scope
    popScope();
    g_currFunc.clear();
    g_currRetType = Type::VOID;
    resetTemps();
  }

  static void emitPrintString(const string& s) {
    for (char c : s) {
      g_code.emit("PRNTC " + std::to_string((unsigned char)c));
    }
  }
%}

%define parse.error verbose

%token TK_INT TK_FLOAT TK_VOID
%token TK_IF TK_THEN TK_ELSE TK_WHILE TK_DO
%token TK_RETURN TK_READ TK_WRITE
%token TK_AND TK_OR TK_NOT
%token TK_ID TK_INTNUM TK_REALNUM TK_STRING TK_RELOP TK_ADDOP TK_MULOP

%right TK_CAST
%left TK_OR
%left TK_AND
%right TK_NOT
%left TK_RELOP
%left TK_ADDOP
%left TK_MULOP

%nonassoc IFX
%nonassoc TK_ELSE

%%

PROG
  : FDEFS
    {
      // Before producing output: any function calls still unresolved in this module
      // must be patched to an invalid placeholder so the linker can later rewrite them:contentReference[oaicite:9]{index=9}
      for (auto& kv : g_functions) {
        auto& fi = kv.second;
        if (!fi.unresolvedCallLines.empty()) {
          // If the function ended up defined, these should have been patched at beginFunction
          // Otherwise keep invalid target
          if (!fi.isDefined) {
            g_code.backpatch(fi.unresolvedCallLines, INVALID_JLINK_TARGET);
          } else {
            g_code.backpatch(fi.unresolvedCallLines, fi.startLineImplementation);
          }
          fi.unresolvedCallLines.clear();
        }
      }

      // Enforce: not more than one main in this module; and if main exists here, it must be void main():contentReference[oaicite:10]{index=10}
      int mains = 0;
      auto it = g_functions.find("main");
      if (it != g_functions.end() && it->second.isDefined) {
        mains = 1;
        if (it->second.retType != Type::VOID || !it->second.paramTypes.empty()) {
          reportSemanticErrorAndExit("main must have signature void main()", yylineno);
        }
      }
      (void)mains;

      // Build header
      std::ostringstream out;
      out << "<header>\n";

      out << "<unimplemented>";
      bool firstUn = true;
      for (const auto& kv : g_functions) {
        const string& fname = kv.first;
        const FunctionInfo& fi = kv.second;
        if (!fi.isDefined && !fi.callLines.empty()) {
          if (firstUn) { out << " "; firstUn = false; }
          else out << " ";
          out << fname;
          for (int cl : fi.callLines) out << "," << cl;
        }
      }
      out << "\n";

      out << "<implemented>";
      bool firstIm = true;
      for (const auto& kv : g_functions) {
        const string& fname = kv.first;
        const FunctionInfo& fi = kv.second;
        if (fi.isDefined) {
          if (firstIm) { out << " "; firstIm = false; }
          else out << " ";
          out << fname << "," << fi.startLineImplementation;
        }
      }
      out << "\n";

      out << "</header>\n";
      out << g_code.str();

      g_final_output = out.str();
    }
  ;

FDEFS
  : FDEFS FUNC_DEF_API BLK
    {
      endFunction($3->nextList);
      $$ = new Attr();
    }
  | FDEFS FUNC_DEC_API ';'
    { $$ = new Attr(); }
  | /* empty */
    { $$ = new Attr(); }
  ;

FUNC_DEC_API
  : TYPE TK_ID '(' ')'
    {
      declareFunction($2->str, $1->type, {}, {}, false);
      $$ = new Attr();
    }
  | TYPE TK_ID '(' FUNC_ARGLIST ')'
    {
      declareFunction($2->str, $1->type, $4->paramTypes, $4->paramNames, false);
      $$ = new Attr();
    }
  ;

FUNC_DEF_API
  : TYPE TK_ID '(' ')'
    {
      declareFunction($2->str, $1->type, {}, {}, true);
      beginFunction($2->str);
      $$ = new Attr();
    }
  | TYPE TK_ID '(' FUNC_ARGLIST ')'
    {
      declareFunction($2->str, $1->type, $4->paramTypes, $4->paramNames, true);
      beginFunction($2->str);
      $$ = new Attr();
    }
  ;

FUNC_ARGLIST
  : TYPE TK_ID
    {
      if ($1->type == Type::VOID) {
        reportSemanticErrorAndExit("parameter cannot be void", yylineno);
      }
      $$ = new Attr();
      $$->paramTypes.push_back($1->type);
      $$->paramNames.push_back($2->str);
    }
  | FUNC_ARGLIST ',' TYPE TK_ID
    {
      if ($3->type == Type::VOID) {
        reportSemanticErrorAndExit("parameter cannot be void", yylineno);
      }
      $$ = $1;
      $$->paramTypes.push_back($3->type);
      $$->paramNames.push_back($4->str);
    }
  ;

TYPE
  : TK_INT   { $$ = new Attr(); $$->type = Type::INT; }
  | TK_FLOAT { $$ = new Attr(); $$->type = Type::FLOAT; }
  | TK_VOID  { $$ = new Attr(); $$->type = Type::VOID; }
  ;

BLK
  : '{' STLIST '}'
    { $$ = $2; }
  ;

STLIST
  : STLIST M STMT
    {
      if (!$1->nextList.empty()) g_code.backpatch($1->nextList, $2->quad);
      $$ = new Attr();
      $$->nextList = $3->nextList;
    }
  | /* empty */
    { $$ = new Attr(); }
  ;

M
  : /* empty */
    { $$ = new Attr(); $$->quad = g_code.nextQuad(); }
  ;

N
  : /* empty */
    {
      $$ = new Attr();
      $$->nextList = { g_code.nextQuad() };
      g_code.emit("UJUMP ");
    }
  ;

IF_COND
  : /* empty */
    { resetTemps(); $$ = new Attr(); }
  ;

STMT
  : DCL ';'
    { $$ = new Attr(); }
  | TK_ID '=' EXP ';'
    {
      VarBinding* vb = lookupVar($1->str);
      if (!vb) reportSemanticErrorAndExit("undeclared variable " + $1->str, yylineno);
      if (vb->type != $3->type) reportSemanticErrorAndExit("type mismatch in assignment", yylineno);

      if ($3->type == Type::INT) emitStoreVarInt($3->reg, vb->offset);
      else if ($3->type == Type::FLOAT) emitStoreVarFloat($3->reg, vb->offset);
      else reportSemanticErrorAndExit("cannot assign void", yylineno);

      resetTemps();
      $$ = new Attr();
    }
  | EXP ';'
    {
      // Semantic rule: EXP derived from STMT must be void:contentReference[oaicite:11]{index=11}
      if ($1->type != Type::VOID) {
        reportSemanticErrorAndExit("expression statement must be void (cast to void if needed)", yylineno);
      }
      resetTemps();
      $$ = new Attr();
    }
  | CNTRL
    { $$ = $1; resetTemps(); }
  | TK_RETURN ';'
    {
      if (g_currRetType != Type::VOID) {
        reportSemanticErrorAndExit("return without value in non-void function", yylineno);
      }
      // Jump to epilogue
      g_returnJumps.push_back(g_code.nextQuad());
      g_code.emit("UJUMP ");
      $$ = new Attr();
    }
  | TK_RETURN EXP ';'
    {
      if (g_currRetType == Type::VOID) {
        reportSemanticErrorAndExit("return with value in void function", yylineno);
      }
      if ($2->type != g_currRetType) {
        reportSemanticErrorAndExit("return type mismatch", yylineno);
      }
      if ($2->type == Type::INT) {
        g_code.emit("COPYI " + Ireg(I_RET) + " " + Ireg($2->reg));
      } else {
        g_code.emit("COPYF " + Freg(F_RET) + " " + Freg($2->reg));
      }
      g_returnJumps.push_back(g_code.nextQuad());
      g_code.emit("UJUMP ");
      $$ = new Attr();
    }
  | TK_READ TK_ID ';'
    {
      VarBinding* vb = lookupVar($2->str);
      if (!vb) reportSemanticErrorAndExit("undeclared variable " + $2->str, yylineno);
      if (vb->type == Type::INT) {
        int r = allocIntReg();
        g_code.emit("READI " + Ireg(r));
        emitStoreVarInt(r, vb->offset);
      } else if (vb->type == Type::FLOAT) {
        int r = allocFloatReg();
        g_code.emit("READF " + Freg(r));
        emitStoreVarFloat(r, vb->offset);
      } else {
        reportSemanticErrorAndExit("read supports only int/float", yylineno);
      }
      resetTemps();
      $$ = new Attr();
    }
  | TK_WRITE EXP ';'
    {
      if ($2->type == Type::INT) {
        g_code.emit("PRNTI " + Ireg($2->reg));
      } else if ($2->type == Type::FLOAT) {
        g_code.emit("PRNTF " + Freg($2->reg));
      } else if ($2->type == Type::STR) {
        emitPrintString($2->str);
      } else {
        reportSemanticErrorAndExit("write does not support void", yylineno);
      }
      resetTemps();
      $$ = new Attr();
    }
  ;

DCL
  : TYPE TK_ID
    {
      if ($1->type == Type::VOID) {
        reportSemanticErrorAndExit("cannot declare variable of type void", yylineno);
      }
      declareVar($2->str, $1->type, g_nextLocalOffset);
      g_nextLocalOffset += 4;
      $$ = new Attr();
    }
  | DCL ',' TK_ID
    {
      // Continue multi-decl with same type
      // The incoming DCL doesn't carry type, so we re-use last declared offset/type by searching.
      // Simpler: keep the type in $$->type, but we keep this rule minimal:
      // We'll assume caller uses "TYPE id , id , id" so first rule above already inserted first variable.
      // Here we just declare new variable with the same type as the first one in this declaration list.
      // We can infer it from the first id in the same statement only if we carry it:
      // We'll store it in $1->type.
      // So: update the first rule to set $$->type, and here use $1->type.
      $$ = $1;
      if ($$->type == Type::VOID) {
        reportSemanticErrorAndExit("cannot declare variable of type void", yylineno);
      }
      declareVar($3->str, $$->type, g_nextLocalOffset);
      g_nextLocalOffset += 4;
    }
  ;

CNTRL
  : TK_IF BEXP IF_COND TK_THEN M STMT %prec IFX
    {
      // if without else:
      // backpatch trueList -> then
      if (!$2->trueList.empty()) g_code.backpatch($2->trueList, $5->quad);
      $$ = new Attr();
      $$->nextList = $2->falseList;
      // then statement may fallthrough
      $$->nextList.insert($$->nextList.end(), $6->nextList.begin(), $6->nextList.end());
    }
  | TK_IF BEXP IF_COND TK_THEN M STMT N TK_ELSE M STMT
    {
      // backpatch trueList -> then
      if (!$2->trueList.empty()) g_code.backpatch($2->trueList, $5->quad);
      // backpatch falseList -> else
      if (!$2->falseList.empty()) g_code.backpatch($2->falseList, $9->quad);
      // then fallthrough -> N jump line (so it jumps over else)
      if (!$6->nextList.empty()) g_code.backpatch($6->nextList, $7->quad);

      $$ = new Attr();
      $$->nextList = $7->nextList;
      $$->nextList.insert($$->nextList.end(), $10->nextList.begin(), $10->nextList.end());
    }
  | TK_WHILE M BEXP IF_COND TK_DO M STMT
    {
      // while:
      // backpatch trueList -> body
      if (!$3->trueList.empty()) g_code.backpatch($3->trueList, $6->quad);
      // backpatch body fallthrough -> condition
      if (!$7->nextList.empty()) g_code.backpatch($7->nextList, $2->quad);
      // unconditional jump back to condition
      g_code.emit("UJUMP " + std::to_string($2->quad));

      $$ = new Attr();
      $$->nextList = $3->falseList;
    }
  ;

BEXP
  : EXP TK_RELOP EXP
    {
      if ($1->type == Type::VOID || $3->type == Type::VOID) {
        reportSemanticErrorAndExit("cannot compare void", yylineno);
      }
      if ($1->type != $3->type) {
        reportSemanticErrorAndExit("type mismatch in comparison", yylineno);
      }

      int condReg = allocIntReg(); // boolean result in int reg
      string op = $2->str;

      if ($1->type == Type::INT) {
        if (op == "==") g_code.emit("SEQUI " + Ireg(condReg) + " " + Ireg($1->reg) + " " + Ireg($3->reg));
        else if (op == "<>") g_code.emit("SNEQI " + Ireg(condReg) + " " + Ireg($1->reg) + " " + Ireg($3->reg));
        else if (op == "<")  g_code.emit("SLETI " + Ireg(condReg) + " " + Ireg($1->reg) + " " + Ireg($3->reg));
        else if (op == ">")  g_code.emit("SGRTI " + Ireg(condReg) + " " + Ireg($1->reg) + " " + Ireg($3->reg));
        else if (op == "<=") {
          // a<=b  == !(a>b)
          int t = allocIntReg();
          g_code.emit("SGRTI " + Ireg(t) + " " + Ireg($1->reg) + " " + Ireg($3->reg));
          // SEQUI condReg t 0
          g_code.emit("SEQUI " + Ireg(condReg) + " " + Ireg(t) + " 0");
        } else if (op == ">=") {
          int t = allocIntReg();
          g_code.emit("SLETI " + Ireg(t) + " " + Ireg($1->reg) + " " + Ireg($3->reg));
          g_code.emit("SEQUI " + Ireg(condReg) + " " + Ireg(t) + " 0");
        }
      } else {
        // FLOAT comparisons use *F opcodes
        if (op == "==") g_code.emit("SEQUF " + Ireg(condReg) + " " + Freg($1->reg) + " " + Freg($3->reg));
        else if (op == "<>") g_code.emit("SNEQF " + Ireg(condReg) + " " + Freg($1->reg) + " " + Freg($3->reg));
        else if (op == "<")  g_code.emit("SLETF " + Ireg(condReg) + " " + Freg($1->reg) + " " + Freg($3->reg));
        else if (op == ">")  g_code.emit("SGRTF " + Ireg(condReg) + " " + Freg($1->reg) + " " + Freg($3->reg));
        else if (op == "<=") {
          int t = allocIntReg();
          g_code.emit("SGRTF " + Ireg(t) + " " + Freg($1->reg) + " " + Freg($3->reg));
          g_code.emit("SEQUI " + Ireg(condReg) + " " + Ireg(t) + " 0");
        } else if (op == ">=") {
          int t = allocIntReg();
          g_code.emit("SLETF " + Ireg(t) + " " + Freg($1->reg) + " " + Freg($3->reg));
          g_code.emit("SEQUI " + Ireg(condReg) + " " + Ireg(t) + " 0");
        }
      }

      // Build true/false lists with branches
      $$ = new Attr();
      $$->trueList = { g_code.nextQuad() };
      g_code.emit("BNEQZ " + Ireg(condReg) + " ");
      $$->falseList = { g_code.nextQuad() };
      g_code.emit("UJUMP ");
    }
  | TK_NOT BEXP
    {
      $$ = new Attr();
      $$->trueList = $2->falseList;
      $$->falseList = $2->trueList;
    }
  | BEXP TK_AND M BEXP
    {
      // short-circuit AND: backpatch left.true -> right
      if (!$1->trueList.empty()) g_code.backpatch($1->trueList, $3->quad);
      $$ = new Attr();
      $$->trueList = $4->trueList;
      $$->falseList = $1->falseList;
      $$->falseList.insert($$->falseList.end(), $4->falseList.begin(), $4->falseList.end());
    }
  | BEXP TK_OR M BEXP
    {
      // short-circuit OR: backpatch left.false -> right
      if (!$1->falseList.empty()) g_code.backpatch($1->falseList, $3->quad);
      $$ = new Attr();
      $$->falseList = $4->falseList;
      $$->trueList = $1->trueList;
      $$->trueList.insert($$->trueList.end(), $4->trueList.begin(), $4->trueList.end());
    }
  | '(' BEXP ')'
    { $$ = $2; }
  ;

EXP
  : LVAL
    { $$ = $1; }
  | TK_INTNUM
    {
      $$ = new Attr();
      $$->type = Type::INT;
      int r = allocIntReg();
      g_code.emit("COPYI " + Ireg(r) + " " + $1->str);
      $$->reg = r;
    }
  | TK_REALNUM
    {
      $$ = new Attr();
      $$->type = Type::FLOAT;
      int r = allocFloatReg();
      g_code.emit("COPYF " + Freg(r) + " " + $1->str);
      $$->reg = r;
    }
  | TK_STRING
    { $$ = $1; /* type=STR, str already holds unescaped */ }
  | EXP TK_ADDOP EXP
    {
      if ($1->type != $3->type) reportSemanticErrorAndExit("type mismatch in arithmetic", yylineno);
      if ($1->type == Type::INT) {
        $$ = new Attr(); $$->type = Type::INT;
        int r = allocIntReg();
        if ($2->str == "+")
          g_code.emit("ADD2I " + Ireg(r) + " " + Ireg($1->reg) + " " + Ireg($3->reg));
        else
          g_code.emit("SUBTI " + Ireg(r) + " " + Ireg($1->reg) + " " + Ireg($3->reg));
        $$->reg = r;
      } else if ($1->type == Type::FLOAT) {
        $$ = new Attr(); $$->type = Type::FLOAT;
        int r = allocFloatReg();
        if ($2->str == "+")
          g_code.emit("ADD2F " + Freg(r) + " " + Freg($1->reg) + " " + Freg($3->reg));
        else
          g_code.emit("SUBTF " + Freg(r) + " " + Freg($1->reg) + " " + Freg($3->reg));
        $$->reg = r;
      } else {
        reportSemanticErrorAndExit("invalid arithmetic", yylineno);
      }
    }
  | EXP TK_MULOP EXP
    {
      if ($1->type != $3->type) reportSemanticErrorAndExit("type mismatch in arithmetic", yylineno);
      if ($1->type == Type::INT) {
        $$ = new Attr(); $$->type = Type::INT;
        int r = allocIntReg();
        if ($2->str == "*")
          g_code.emit("MULTI " + Ireg(r) + " " + Ireg($1->reg) + " " + Ireg($3->reg));
        else
          g_code.emit("DIVDI " + Ireg(r) + " " + Ireg($1->reg) + " " + Ireg($3->reg));
        $$->reg = r;
      } else if ($1->type == Type::FLOAT) {
        $$ = new Attr(); $$->type = Type::FLOAT;
        int r = allocFloatReg();
        if ($2->str == "*")
          g_code.emit("MULTF " + Freg(r) + " " + Freg($1->reg) + " " + Freg($3->reg));
        else
          g_code.emit("DIVDF " + Freg(r) + " " + Freg($1->reg) + " " + Freg($3->reg));
        $$->reg = r;
      } else {
        reportSemanticErrorAndExit("invalid arithmetic", yylineno);
      }
    }
  | '(' EXP ')'
    { $$ = $2; }
  | '(' TYPE ')' EXP %prec TK_CAST
    {
      // explicit cast has high precedence per spec:contentReference[oaicite:12]{index=12}
      if ($2->type == Type::VOID) {
        // cast-to-void allowed; value discarded
        $$ = new Attr();
        $$->type = Type::VOID;
      } else if ($2->type == Type::INT && $4->type == Type::FLOAT) {
        $$ = new Attr(); $$->type = Type::INT;
        int r = allocIntReg();
        g_code.emit("CFTOI " + Ireg(r) + " " + Freg($4->reg));
        $$->reg = r;
      } else if ($2->type == Type::FLOAT && $4->type == Type::INT) {
        $$ = new Attr(); $$->type = Type::FLOAT;
        int r = allocFloatReg();
        g_code.emit("CITOF " + Freg(r) + " " + Ireg($4->reg));
        $$->reg = r;
      } else if ($2->type == $4->type) {
        $$ = $4;
      } else {
        reportSemanticErrorAndExit("unsupported cast", yylineno);
      }
    }
  | CALL
    { $$ = $1; }
  ;

LVAL
  : TK_ID
    {
      VarBinding* vb = lookupVar($1->str);
      if (!vb) reportSemanticErrorAndExit("undeclared variable " + $1->str, yylineno);

      $$ = new Attr();
      $$->type = vb->type;
      if (vb->type == Type::INT) {
        int r = allocIntReg();
        emitLoadVarInt(r, vb->offset);
        $$->reg = r;
      } else if (vb->type == Type::FLOAT) {
        int r = allocFloatReg();
        emitLoadVarFloat(r, vb->offset);
        $$->reg = r;
      } else {
        reportSemanticErrorAndExit("invalid lval type", yylineno);
      }
    }
  ;

CALL
  : TK_ID '(' CALL_ARGS ')'
    {
      const string fname = $1->str;

      auto it = g_functions.find(fname);
      if (it == g_functions.end()) {
        reportSemanticErrorAndExit("call to undeclared function " + fname, yylineno);
      }
      const FunctionInfo& fi = it->second;

      // Build final arg list by parameter order
      int n = (int)fi.paramTypes.size();
      vector<int> actualRegs(n, -1);

      // 1) place positional
      int posCount = 0;
      for (size_t i = 0; i < $3->argRegs.size(); ++i) {
        if ($3->argNames[i].empty()) {
          if (posCount >= n) {
            reportSemanticErrorAndExit("too many positional arguments in call to " + fname, yylineno);
          }
          actualRegs[posCount++] = $3->argRegs[i];
        }
      }

      // 2) place named
      for (size_t i = 0; i < $3->argRegs.size(); ++i) {
        if (!$3->argNames[i].empty()) {
          const string& pname = $3->argNames[i];
          auto pit = std::find(fi.paramNames.begin(), fi.paramNames.end(), pname);
          if (pit == fi.paramNames.end()) {
            reportSemanticErrorAndExit("unknown named parameter " + pname + " in call to " + fname, yylineno);
          }
          int idx = (int)std::distance(fi.paramNames.begin(), pit);
          if (actualRegs[idx] != -1) {
            reportSemanticErrorAndExit("duplicate argument for parameter " + pname + " in call to " + fname, yylineno);
          }
          actualRegs[idx] = $3->argRegs[i];
        }
      }

      // Must fill all params
      for (int i = 0; i < n; ++i) {
        if (actualRegs[i] == -1) {
          reportSemanticErrorAndExit("missing argument for parameter " + fi.paramNames[i] + " in call to " + fname, yylineno);
        }
      }

      // Type-check args
      // (We need the arg types too, so we rely on reg ranges: int regs >= INT_TMP_BASE, float regs >= FLOAT_TMP_BASE.
      // Better: carry type with args. For simplicity here: we infer from fi.paramTypes and assume caller built regs correctly.
      // In this project, EXP already type-checks, so we can safely assume correctness if we pass regs from EXP.
      // We'll do strict: if param is INT then arg reg must be an int temp, if FLOAT then float temp.
      for (int i = 0; i < n; ++i) {
        if (fi.paramTypes[i] == Type::INT) {
          // ok if it came from INT expression or constant loads -> int reg
        } else if (fi.paramTypes[i] == Type::FLOAT) {
          // ok if float expression -> float reg
        } else {
          reportSemanticErrorAndExit("cannot have void parameter", yylineno);
        }
      }

      // Save temps (caller-saved) because "any register can change" across call:contentReference[oaicite:13]{index=13}
      int intUsed = g_nextIntReg - INT_TMP_BASE;
      int fltUsed = g_nextFloatReg - FLOAT_TMP_BASE;
      int saveSize = 4 * (intUsed + fltUsed);

      if (saveSize > 0) {
        int off = 0;
        // save int temps
        for (int r = INT_TMP_BASE; r < g_nextIntReg; ++r) {
          g_code.emit("STORI " + Ireg(r) + " " + Ireg(I_SP) + " " + std::to_string(off));
          off += 4;
        }
        // save float temps (base must be float reg)
        syncFloatSP();
        for (int r = FLOAT_TMP_BASE; r < g_nextFloatReg; ++r) {
          g_code.emit("STORF " + Freg(r) + " " + Freg(F_SP) + " " + std::to_string(off));
          off += 4;
        }
        g_code.emit("ADD2I " + Ireg(I_SP) + " " + Ireg(I_SP) + " " + std::to_string(saveSize));
        syncFloatSP();
      }

      // Push args in order
      for (int i = 0; i < n; ++i) {
        if (fi.paramTypes[i] == Type::INT) {
          g_code.emit("STORI " + Ireg(actualRegs[i]) + " " + Ireg(I_SP) + " 0");
          g_code.emit("ADD2I " + Ireg(I_SP) + " " + Ireg(I_SP) + " 4");
          syncFloatSP();
        } else { // FLOAT
          syncFloatSP();
          g_code.emit("STORF " + Freg(actualRegs[i]) + " " + Freg(F_SP) + " 0");
          g_code.emit("ADD2I " + Ireg(I_SP) + " " + Ireg(I_SP) + " 4");
          syncFloatSP();
        }
      }

      // Emit call (JLINK) and record call site
      int callLine = g_code.nextQuad();
      g_code.emit("JLINK ");
      g_functions[fname].callLines.push_back(callLine);

      if (g_functions[fname].isDefined) {
        g_code.backpatch({callLine}, g_functions[fname].startLineImplementation);
      } else {
        g_functions[fname].unresolvedCallLines.push_back(callLine);
      }

      // Pop args
      int argSize = 4 * n;
      if (argSize > 0) {
        g_code.emit("SUBTI " + Ireg(I_SP) + " " + Ireg(I_SP) + " " + std::to_string(argSize));
        syncFloatSP();
      }

      // Restore temps
      if (saveSize > 0) {
        // base = SP - saveSize
        g_code.emit("SUBTI " + Ireg(I_TMP) + " " + Ireg(I_SP) + " " + std::to_string(saveSize));

        int off = 0;
        for (int r = INT_TMP_BASE; r < g_nextIntReg; ++r) {
          g_code.emit("LOADI " + Ireg(r) + " " + Ireg(I_TMP) + " " + std::to_string(off));
          off += 4;
        }

        // float temps start after int temps
        g_code.emit("CITOF " + Freg(F_BASE) + " " + Ireg(I_TMP));
        int offF = 4 * intUsed;
        for (int r = FLOAT_TMP_BASE; r < g_nextFloatReg; ++r) {
          g_code.emit("LOADF " + Freg(r) + " " + Freg(F_BASE) + " " + std::to_string(offF));
          offF += 4;
        }

        g_code.emit("SUBTI " + Ireg(I_SP) + " " + Ireg(I_SP) + " " + std::to_string(saveSize));
        syncFloatSP();
      }

      // Re-sync float bases, because callee may clobber F1/F2 even if FP/SP unchanged
      syncFloatBases();

      // Return value
      $$ = new Attr();
      if (fi.retType == Type::INT) {
        $$->type = Type::INT;
        int r = allocIntReg();
        g_code.emit("COPYI " + Ireg(r) + " " + Ireg(I_RET));
        $$->reg = r;
      } else if (fi.retType == Type::FLOAT) {
        $$->type = Type::FLOAT;
        int r = allocFloatReg();
        g_code.emit("COPYF " + Freg(r) + " " + Freg(F_RET));
        $$->reg = r;
      } else {
        $$->type = Type::VOID;
      }
    }
  ;

CALL_ARGS
  : /* empty */
    { $$ = new Attr(); }
  | POS_ARGLIST
    { $$ = $1; }
  | NAMED_ARGLIST
    { $$ = $1; }
  | POS_ARGLIST ',' NAMED_ARGLIST
    {
      // concat: positional first, then named
      $$ = new Attr();
      $$->argRegs = $1->argRegs;
      $$->argNames = $1->argNames;

      $$->argRegs.insert($$->argRegs.end(), $3->argRegs.begin(), $3->argRegs.end());
      $$->argNames.insert($$->argNames.end(), $3->argNames.begin(), $3->argNames.end());
    }
  ;

POS_ARGLIST
  : EXP
    {
      $$ = new Attr();
      $$->argRegs.push_back($1->reg);
      $$->argNames.push_back(""); // positional
    }
  | POS_ARGLIST ',' EXP
    {
      $$ = $1;
      $$->argRegs.push_back($3->reg);
      $$->argNames.push_back("");
    }
  ;

NAMED_ARGLIST
  : EXP ':' TK_ID
    {
      $$ = new Attr();
      $$->argRegs.push_back($1->reg);
      $$->argNames.push_back($3->str);
    }
  | NAMED_ARGLIST ',' EXP ':' TK_ID
    {
      $$ = $1;
      $$->argRegs.push_back($3->reg);
      $$->argNames.push_back($5->str);
    }
  ;

%%

void yyerror(const char*) {
  // When bison reports syntax error, use current lexeme (or EOF)
  std::string lex = g_curr_lexeme.empty() ? "EOF" : g_curr_lexeme;
  reportSyntaxErrorAndExit(lex, yylineno);
}
