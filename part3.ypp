%{
#include <cstdio>
#include <cstdlib>
#include <cstring>

#include <fstream>
#include <iostream>
#include <map>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <vector>

#include "part3_helpers.hpp"

using std::cerr;
using std::endl;
using std::string;
using std::vector;

extern int yylex(void);
extern int yylineno;
extern char* yytext;
extern FILE* yyin;

void yyerror(const char* s);

// -------------------- Global compiler state --------------------

struct VarBinding {
    Type type;
    int offset; // bytes relative to FP
};

struct FunctionInfo {
    Type returnType = void_t;
    vector<Type> paramTypes;
    vector<string> paramNames;

    bool isDefined = false;
    int startLineImplementation = 0;

    vector<int> callLines;
    vector<int> unresolvedCallLines;
};

static CodeBuffer g_code;
static std::map<string, FunctionInfo> g_functions;

static std::unordered_map<string, vector<VarBinding>> g_vars;
static vector<std::unordered_set<string>> g_scopes;

static int g_blockDepth = 0;
static bool g_paramsInserted = false;

static string g_currentFunc;
static Type g_currentReturnType = void_t;
static vector<Type> g_currentParamTypes;
static vector<string> g_currentParamNames;
static vector<int> g_currentReturnJumps;

static constexpr int INT_TMP_BASE   = 11;
static constexpr int FLOAT_TMP_BASE = 10;

// Reserve F0 as "address scratch" for LOADF/STORF base conversion.
static constexpr int F_ADDR_SCRATCH = 0;

static int g_nextIntReg   = INT_TMP_BASE;
static int g_nextFloatReg = FLOAT_TMP_BASE;

static int g_nextLocalOffset = 8;
static int g_localAllocInstrLine = -1;

// -------------------- Error helpers (canonical messages) --------------------

[[noreturn]] static void semanticErrorFixed(const char* msg) {
    cerr << "Semantic error: " << msg << " in line number " << yylineno << endl;
    std::exit(SEMANTIC_ERROR);
}

[[noreturn]] static void operationalError(const string& msg) {
    cerr << "Operational error: " << msg << endl;
    std::exit(OPERATIONAL_ERROR);
}

// Canonical semantic messages expected by your tests:
static constexpr const char* SEM_DUP_PARAM_NAME   = "Duplicate parameter name";
static constexpr const char* SEM_UNDECL_VAR       = "Undeclared variable";
static constexpr const char* SEM_VAR_REDECL       = "Variable already declared";
static constexpr const char* SEM_FUNC_REDEF       = "Function redefined";
static constexpr const char* SEM_WRONG_NUM_ARGS   = "Wrong number of arguments";
static constexpr const char* SEM_UNKNOWN_NAMED    = "Unknown named parameter";
static constexpr const char* SEM_PARAM_TWICE      = "Parameter passed twice";
static constexpr const char* SEM_MUST_RET_VALUE   = "Must return value from non-void function";
static constexpr const char* SEM_CANT_RET_VALUE   = "Cannot return value from void function";

// For other semantic errors not covered by your message-tests:
static constexpr const char* SEM_TYPE_MISMATCH    = "Type mismatch";
static constexpr const char* SEM_ILLEGAL_VOID     = "Illegal use of void";
static constexpr const char* SEM_UNDECL_FUNC      = "Undeclared function";

// -------------------- Small utilities --------------------

static inline string Ireg(int r) { return "I" + std::to_string(r); }
static inline string Freg(int r) { return "F" + std::to_string(r); }

static inline string Faddr() { return Freg(F_ADDR_SCRATCH); }

static inline void addrToF0FromI(const string& ibase) {
    g_code.emit("CITOF " + Faddr() + " " + ibase);
}

static inline void resetTemps() {
    g_nextIntReg = INT_TMP_BASE;
    g_nextFloatReg = FLOAT_TMP_BASE;
}

static inline int allocIntReg()   { return g_nextIntReg++; }
static inline int allocFloatReg() { return g_nextFloatReg++; }

static inline bool sameSignature(const FunctionInfo& a, const FunctionInfo& b) {
    return a.returnType == b.returnType &&
           a.paramTypes == b.paramTypes &&
           a.paramNames == b.paramNames;
}

static VarBinding lookupVar(const string& name) {
    auto it = g_vars.find(name);
    if (it == g_vars.end() || it->second.empty()) {
        semanticErrorFixed(SEM_UNDECL_VAR);
    }
    return it->second.back();
}

static bool declaredInCurrentScope(const string& name) {
    if (g_scopes.empty()) return false;
    return g_scopes.back().find(name) != g_scopes.back().end();
}

static void pushScope() {
    g_scopes.emplace_back();
}

static void popScope() {
    if (g_scopes.empty()) return;
    for (const auto& name : g_scopes.back()) {
        auto it = g_vars.find(name);
        if (it != g_vars.end() && !it->second.empty()) {
            it->second.pop_back();
            if (it->second.empty()) g_vars.erase(it);
        }
    }
    g_scopes.pop_back();
}

static void declareVarWithOffset(const string& name, Type t, int offset) {
    if (t == void_t) semanticErrorFixed(SEM_ILLEGAL_VOID);
    if (declaredInCurrentScope(name)) semanticErrorFixed(SEM_VAR_REDECL);

    g_scopes.back().insert(name);
    g_vars[name].push_back(VarBinding{t, offset});
}

static void declareLocal(const string& name, Type t) {
    const int offset = g_nextLocalOffset;
    g_nextLocalOffset += 4;
    declareVarWithOffset(name, t, offset);
}

static void insertParamsIntoCurrentScope() {
    if (g_paramsInserted) return;

    const int n = static_cast<int>(g_currentParamTypes.size());
    for (int i = 0; i < n; ++i) {
        const string& pname = g_currentParamNames[i];
        const Type ptype = g_currentParamTypes[i];

        if (ptype == void_t) semanticErrorFixed(SEM_ILLEGAL_VOID);

        // FP points to end-of-args:
        // param[i] offset = -4*(n - i)
        const int offset = -4 * (n - i);
        declareVarWithOffset(pname, ptype, offset);
    }
    g_paramsInserted = true;
}

static void declareFunction(const string& name, Type retType,
                            const vector<Type>& paramTypes,
                            const vector<string>& paramNames,
                            bool isDefinition) {
    FunctionInfo sig;
    sig.returnType = retType;
    sig.paramTypes = paramTypes;
    sig.paramNames = paramNames;

    if (sig.paramTypes.size() != sig.paramNames.size()) {
        semanticErrorFixed(SEM_FUNC_REDEF);
    }

    {
        std::unordered_set<string> seen;
        for (size_t i = 0; i < sig.paramNames.size(); ++i) {
            if (!seen.insert(sig.paramNames[i]).second) {
                semanticErrorFixed(SEM_DUP_PARAM_NAME);
            }
            if (sig.paramTypes[i] == void_t) {
                semanticErrorFixed(SEM_ILLEGAL_VOID);
            }
        }
    }

    // IMPORTANT: Do NOT enforce any special signature for main here.
    // The PDF says different main API leads to undefined behavior at runtime,
    // not a compiler semantic error. :contentReference[oaicite:2]{index=2}

    auto it = g_functions.find(name);
    if (it == g_functions.end()) {
        FunctionInfo info = sig;
        info.isDefined = false;
        info.startLineImplementation = 0;
        g_functions.emplace(name, std::move(info));
        it = g_functions.find(name);
    } else {
        FunctionInfo existingSig = it->second;
        existingSig.isDefined = false;
        existingSig.startLineImplementation = 0;
        existingSig.callLines.clear();
        existingSig.unresolvedCallLines.clear();

        if (!sameSignature(existingSig, sig)) {
            semanticErrorFixed(SEM_FUNC_REDEF);
        }
        if (isDefinition && it->second.isDefined) {
            semanticErrorFixed(SEM_FUNC_REDEF);
        }
    }

    if (isDefinition) it->second.isDefined = true;
}

static void beginFunction(const string& name) {
    auto it = g_functions.find(name);
    if (it == g_functions.end()) semanticErrorFixed(SEM_FUNC_REDEF);

    g_currentFunc = name;
    g_currentReturnType = it->second.returnType;
    g_currentParamTypes = it->second.paramTypes;
    g_currentParamNames = it->second.paramNames;

    g_vars.clear();
    g_scopes.clear();
    g_blockDepth = 0;
    g_paramsInserted = false;

    resetTemps();
    g_nextLocalOffset = 8;
    g_localAllocInstrLine = -1;
    g_currentReturnJumps.clear();

    const int startLine = g_code.nextQuad();
    it->second.startLineImplementation = startLine;

    if (!it->second.unresolvedCallLines.empty()) {
        g_code.backpatch(it->second.unresolvedCallLines, startLine);
        it->second.unresolvedCallLines.clear();
    }

    // Prologue (same as previous baseline)
    g_code.emit("COPYI I4 I1");    // I4 = old FP
    g_code.emit("COPYI I1 I2");    // FP = SP (end-of-args)
    g_code.emit("STORI I4 I1 0");  // save old FP
    g_code.emit("STORI I0 I1 4");  // save return address

    // allocate header+locals (patched later)
    g_localAllocInstrLine = g_code.nextQuad();
    g_code.emit("ADD2I I2 I2 ");
}

static void endFunction(const vector<int>& blkNextList) {
    const int frameSize = g_nextLocalOffset;
    g_code.backpatch(vector<int>{g_localAllocInstrLine}, frameSize);

    const int epilogueStart = g_code.nextQuad();
    g_code.backpatch(g_currentReturnJumps, epilogueStart);
    g_code.backpatch(blkNextList, epilogueStart);

    g_code.emit("LOADI I4 I1 0");
    g_code.emit("LOADI I0 I1 4");
    g_code.emit("COPYI I2 I1");
    g_code.emit("COPYI I1 I4");
    g_code.emit("RETRN");

    g_currentFunc.clear();
    g_currentReturnType = void_t;
    g_currentParamTypes.clear();
    g_currentParamNames.clear();
    g_currentReturnJumps.clear();
    g_blockDepth = 0;
    g_paramsInserted = false;
    resetTemps();
}

static void emitPrintString(const string& s) {
    for (size_t i = 0; i < s.size(); ++i) {
        unsigned char ch = static_cast<unsigned char>(s[i]);
        if (ch == '\\') {
            if (i + 1 >= s.size()) semanticErrorFixed(SEM_TYPE_MISMATCH);
            const char esc = s[i + 1];
            i++;
            switch (esc) {
                case 'n': ch = '\n'; break;
                case 't': ch = '\t'; break;
                case '"': ch = '"'; break;
                case '\\': ch = '\\'; break;
                default: semanticErrorFixed(SEM_TYPE_MISMATCH);
            }
        }
        g_code.emit("PRNTC " + std::to_string(static_cast<int>(ch)));
    }
}

%}

%code requires {
#include "part3_helpers.hpp"
}

%union { Attr* a; }

%token TK_INT TK_FLOAT TK_VOID
%token TK_IF TK_THEN TK_ELSE
%token TK_WHILE TK_DO
%token TK_READ TK_WRITE
%token TK_RETURN

%token TK_AND TK_OR TK_NOT
%token TK_ASSIGN

%token <a> TK_ID
%token <a> TK_INTEGERNUM TK_REALNUM
%token <a> TK_STR
%token <a> TK_RELOP TK_ADDOP TK_MULOP

%token TK_CAST

%type <a> PROGRAM FDEFS
%type <a> FUNC_DEC_API FUNC_DEF_API TYPE FUNC_ARGLIST DCL
%type <a> BLK BLK_BEGIN BLK_END STLIST STMT CNTRL IF_COND
%type <a> ASSN READ WRITE RETURN
%type <a> EXP NUM CALL CALL_ARGS POS_ARGLIST NAMED_ARGLIST NAMED_ARG
%type <a> LVAL
%type <a> BEXP M N

%left TK_OR
%left TK_AND
%left TK_RELOP
%left TK_ADDOP
%left TK_MULOP
%right TK_NOT
%right TK_CAST
%nonassoc IF_NO_ELSE
%nonassoc TK_ELSE

%%

PROGRAM
    : FDEFS
    ;

FDEFS
    : FDEFS FUNC_DEC_API
    | FDEFS FUNC_DEF_API { beginFunction($2->str); } BLK { endFunction($4->nextList); }
    | /* empty */ { $$ = new Attr(); }
    ;

FUNC_DEC_API
    : TYPE TK_ID '(' ')' ';'
        { declareFunction($2->str, $1->type, {}, {}, false); $$ = new Attr(); }
    | TYPE TK_ID '(' FUNC_ARGLIST ')' ';'
        { declareFunction($2->str, $1->type, $4->paramTypes, $4->paramNames, false); $$ = new Attr(); }
    ;

FUNC_DEF_API
    : TYPE TK_ID '(' ')'
        { declareFunction($2->str, $1->type, {}, {}, true); $$ = new Attr(); $$->str = $2->str; }
    | TYPE TK_ID '(' FUNC_ARGLIST ')'
        { declareFunction($2->str, $1->type, $4->paramTypes, $4->paramNames, true); $$ = new Attr(); $$->str = $2->str; }
    ;

TYPE
    : TK_INT   { $$ = new Attr(); $$->type = int_; }
    | TK_FLOAT { $$ = new Attr(); $$->type = float_; }
    | TK_VOID  { $$ = new Attr(); $$->type = void_t; }
    ;

FUNC_ARGLIST
    : FUNC_ARGLIST ',' DCL
        {
            $$ = $1;
            for (size_t i = 0; i < $3->names.size(); ++i) {
                $$->paramNames.push_back($3->names[i]);
                $$->paramTypes.push_back($3->type);
            }
        }
    | DCL
        {
            $$ = new Attr();
            for (size_t i = 0; i < $1->names.size(); ++i) {
                $$->paramNames.push_back($1->names[i]);
                $$->paramTypes.push_back($1->type);
            }
        }
    ;

DCL
    : TK_ID ':' TYPE
        { $$ = new Attr(); $$->type = $3->type; $$->names.push_back($1->str); }
    | TK_ID ',' DCL
        { $$ = $3; $$->names.insert($$->names.begin(), $1->str); }
    ;

BLK
    : '{' BLK_BEGIN STLIST '}' BLK_END { $$ = $3; }
    ;

BLK_BEGIN
    : /* empty */
        {
            pushScope();
            g_blockDepth++;
            if (g_blockDepth == 1) insertParamsIntoCurrentScope();
            $$ = new Attr();
        }
    ;

BLK_END
    : /* empty */
        {
            popScope();
            g_blockDepth--;
            $$ = new Attr();
        }
    ;

STLIST
    : STLIST M STMT
        {
            g_code.backpatch($1->nextList, $2->quad);
            $$ = new Attr();
            $$->nextList = $3->nextList;
        }
    | /* empty */ { $$ = new Attr(); }
    ;

M
    : /* empty */ { $$ = new Attr(); $$->quad = g_code.nextQuad(); }
    ;

N
    : /* empty */
        {
            $$ = new Attr();
            $$->nextList = vector<int>{g_code.nextQuad()};
            g_code.emit("UJUMP ");
        }
    ;

STMT
    : DCL ';'
        {
            for (const auto& name : $1->names) declareLocal(name, $1->type);
            $$ = new Attr();
            resetTemps();
        }
    | ASSN { $$ = new Attr(); resetTemps(); }
    | EXP ';'
        {
            if ($1->type != void_t) semanticErrorFixed(SEM_TYPE_MISMATCH);
            $$ = new Attr();
            resetTemps();
        }
    | CNTRL { $$ = $1; resetTemps(); }
    | READ  { $$ = new Attr(); resetTemps(); }
    | WRITE { $$ = new Attr(); resetTemps(); }
    | RETURN { $$ = new Attr(); resetTemps(); }
    | BLK { $$ = $1; resetTemps(); }
    ;

ASSN
    : LVAL TK_ASSIGN EXP ';'
        {
            if ($1->type == void_t || $3->type == void_t) semanticErrorFixed(SEM_ILLEGAL_VOID);
            if ($1->type != $3->type) semanticErrorFixed(SEM_TYPE_MISMATCH);

            if ($1->type == int_) {
                g_code.emit("STORI " + Ireg($3->reg) + " I1 " + std::to_string($1->offset));
            } else {
                addrToF0FromI("I1");
                g_code.emit("STORF " + Freg($3->reg) + " " + Faddr() + " " + std::to_string($1->offset));
            }
            $$ = new Attr();
        }
    ;

LVAL
    : TK_ID
        {
            VarBinding vb = lookupVar($1->str);
            $$ = new Attr();
            $$->type = vb.type;
            $$->offset = vb.offset;
        }
    ;

READ
    : TK_READ '(' LVAL ')' ';'
        {
            if ($3->type == void_t) semanticErrorFixed(SEM_ILLEGAL_VOID);
            if ($3->type == int_) {
                const int r = allocIntReg();
                g_code.emit("READI " + Ireg(r));
                g_code.emit("STORI " + Ireg(r) + " I1 " + std::to_string($3->offset));
            } else {
                const int r = allocFloatReg();
                g_code.emit("READF " + Freg(r));
                addrToF0FromI("I1");
                g_code.emit("STORF " + Freg(r) + " " + Faddr() + " " + std::to_string($3->offset));
            }
            $$ = new Attr();
        }
    ;

WRITE
    : TK_WRITE '(' EXP ')' ';'
        {
            if ($3->type == int_) g_code.emit("PRNTI " + Ireg($3->reg));
            else if ($3->type == float_) g_code.emit("PRNTF " + Freg($3->reg));
            else semanticErrorFixed(SEM_TYPE_MISMATCH);
            $$ = new Attr();
        }
    | TK_WRITE '(' TK_STR ')' ';'
        { emitPrintString($3->str); $$ = new Attr(); }
    ;

RETURN
    : TK_RETURN EXP ';'
        {
            if (g_currentReturnType == void_t) semanticErrorFixed(SEM_CANT_RET_VALUE);
            if ($2->type != g_currentReturnType) semanticErrorFixed(SEM_TYPE_MISMATCH);

            if (g_currentReturnType == int_) g_code.emit("COPYI I3 " + Ireg($2->reg));
            else g_code.emit("COPYF F3 " + Freg($2->reg));

            const int j = g_code.nextQuad();
            g_code.emit("UJUMP ");
            g_currentReturnJumps.push_back(j);
            $$ = new Attr();
        }
    | TK_RETURN ';'
        {
            if (g_currentReturnType != void_t) semanticErrorFixed(SEM_MUST_RET_VALUE);
            const int j = g_code.nextQuad();
            g_code.emit("UJUMP ");
            g_currentReturnJumps.push_back(j);
            $$ = new Attr();
        }
    ;

IF_COND
    : TK_IF BEXP { resetTemps(); $$ = $2; }
    ;

CNTRL
    : IF_COND TK_THEN M STMT TK_ELSE N M STMT
        {
            g_code.backpatch($1->trueList, $3->quad);
            g_code.backpatch($1->falseList, $7->quad);

            $$ = new Attr();
            $$->nextList = mergeLists(mergeLists($4->nextList, $6->nextList), $8->nextList);
        }
    | IF_COND TK_THEN M STMT %prec IF_NO_ELSE
        {
            g_code.backpatch($1->trueList, $3->quad);
            $$ = new Attr();
            $$->nextList = mergeLists($1->falseList, $4->nextList);
        }
    | TK_WHILE M BEXP { resetTemps(); } TK_DO M STMT
        {
            g_code.backpatch($3->trueList, $6->quad);
            g_code.backpatch($7->nextList, $2->quad);
            g_code.emit("UJUMP " + std::to_string($2->quad));
            $$ = new Attr();
            $$->nextList = $3->falseList;
        }
    ;

BEXP
    : BEXP TK_OR M BEXP
        {
            g_code.backpatch($1->falseList, $3->quad);
            $$ = new Attr();
            $$->trueList = mergeLists($1->trueList, $4->trueList);
            $$->falseList = $4->falseList;
        }
    | BEXP TK_AND M BEXP
        {
            g_code.backpatch($1->trueList, $3->quad);
            $$ = new Attr();
            $$->trueList = $4->trueList;
            $$->falseList = mergeLists($1->falseList, $4->falseList);
        }
    | TK_NOT BEXP
        { $$ = new Attr(); $$->trueList = $2->falseList; $$->falseList = $2->trueList; }
    | EXP TK_RELOP EXP
        {
            if ($1->type == void_t || $3->type == void_t) semanticErrorFixed(SEM_ILLEGAL_VOID);
            if ($1->type != $3->type) semanticErrorFixed(SEM_TYPE_MISMATCH);

            const string& op = $2->str;
            int condI = -1;

            if ($1->type == int_) {
                condI = allocIntReg();
                if (op == "==")      g_code.emit("SEQUI " + Ireg(condI) + " " + Ireg($1->reg) + " " + Ireg($3->reg));
                else if (op == "<>") g_code.emit("SNEQI " + Ireg(condI) + " " + Ireg($1->reg) + " " + Ireg($3->reg));
                else if (op == "<")  g_code.emit("SLETI " + Ireg(condI) + " " + Ireg($1->reg) + " " + Ireg($3->reg));
                else if (op == ">")  g_code.emit("SGRTI " + Ireg(condI) + " " + Ireg($1->reg) + " " + Ireg($3->reg));
                else if (op == "<=") g_code.emit("SGRTI " + Ireg(condI) + " " + Ireg($1->reg) + " " + Ireg($3->reg));
                else if (op == ">=") g_code.emit("SLETI " + Ireg(condI) + " " + Ireg($1->reg) + " " + Ireg($3->reg));
                else semanticErrorFixed(SEM_TYPE_MISMATCH);
            } else {
                const int condF = allocFloatReg();
                if (op == "==")      g_code.emit("SEQUF " + Freg(condF) + " " + Freg($1->reg) + " " + Freg($3->reg));
                else if (op == "<>") g_code.emit("SNEQF " + Freg(condF) + " " + Freg($1->reg) + " " + Freg($3->reg));
                else if (op == "<")  g_code.emit("SLETF " + Freg(condF) + " " + Freg($1->reg) + " " + Freg($3->reg));
                else if (op == ">")  g_code.emit("SGRTF " + Freg(condF) + " " + Freg($1->reg) + " " + Freg($3->reg));
                else if (op == "<=") g_code.emit("SGRTF " + Freg(condF) + " " + Freg($1->reg) + " " + Freg($3->reg));
                else if (op == ">=") g_code.emit("SLETF " + Freg(condF) + " " + Freg($1->reg) + " " + Freg($3->reg));
                else semanticErrorFixed(SEM_TYPE_MISMATCH);

                condI = allocIntReg();
                g_code.emit("CFTOI " + Ireg(condI) + " " + Freg(condF));
            }

            const bool trueOnZero = (op == "<=" || op == ">=");

            $$ = new Attr();
            const int bline = g_code.nextQuad();
            if (trueOnZero) g_code.emit("BREQZ " + Ireg(condI) + " ");
            else            g_code.emit("BNEQZ " + Ireg(condI) + " ");
            $$->trueList.push_back(bline);

            const int jline = g_code.nextQuad();
            g_code.emit("UJUMP ");
            $$->falseList.push_back(jline);
        }
    | '(' BEXP ')'
        { $$ = $2; }
    ;

EXP
    : EXP TK_ADDOP EXP
        {
            if ($1->type == void_t || $3->type == void_t) semanticErrorFixed(SEM_ILLEGAL_VOID);
            if ($1->type != $3->type) semanticErrorFixed(SEM_TYPE_MISMATCH);

            const string& op = $2->str;
            $$ = new Attr();
            $$->type = $1->type;

            if ($1->type == int_) {
                const int dst = $1->reg;
                if (op == "+") g_code.emit("ADD2I " + Ireg(dst) + " " + Ireg(dst) + " " + Ireg($3->reg));
                else if (op == "-") g_code.emit("SUBTI " + Ireg(dst) + " " + Ireg(dst) + " " + Ireg($3->reg));
                else semanticErrorFixed(SEM_TYPE_MISMATCH);
                $$->reg = dst;
            } else {
                const int dst = $1->reg;
                if (op == "+") g_code.emit("ADD2F " + Freg(dst) + " " + Freg(dst) + " " + Freg($3->reg));
                else if (op == "-") g_code.emit("SUBTF " + Freg(dst) + " " + Freg(dst) + " " + Freg($3->reg));
                else semanticErrorFixed(SEM_TYPE_MISMATCH);
                $$->reg = dst;
            }
        }
    | EXP TK_MULOP EXP
        {
            if ($1->type == void_t || $3->type == void_t) semanticErrorFixed(SEM_ILLEGAL_VOID);
            if ($1->type != $3->type) semanticErrorFixed(SEM_TYPE_MISMATCH);

            const string& op = $2->str;
            $$ = new Attr();
            $$->type = $1->type;

            if ($1->type == int_) {
                const int dst = $1->reg;
                if (op == "*") g_code.emit("MULTI " + Ireg(dst) + " " + Ireg(dst) + " " + Ireg($3->reg));
                else if (op == "/") g_code.emit("DIVDI " + Ireg(dst) + " " + Ireg(dst) + " " + Ireg($3->reg));
                else semanticErrorFixed(SEM_TYPE_MISMATCH);
                $$->reg = dst;
            } else {
                const int dst = $1->reg;
                if (op == "*") g_code.emit("MULTF " + Freg(dst) + " " + Freg(dst) + " " + Freg($3->reg));
                else if (op == "/") g_code.emit("DIVDF " + Freg(dst) + " " + Freg(dst) + " " + Freg($3->reg));
                else semanticErrorFixed(SEM_TYPE_MISMATCH);
                $$->reg = dst;
            }
        }
    | TK_ID
        {
            VarBinding vb = lookupVar($1->str);
            $$ = new Attr();
            $$->type = vb.type;
            $$->offset = vb.offset;

            if (vb.type == int_) {
                const int r = allocIntReg();
                g_code.emit("LOADI " + Ireg(r) + " I1 " + std::to_string(vb.offset));
                $$->reg = r;
            } else if (vb.type == float_) {
                const int r = allocFloatReg();
                addrToF0FromI("I1");
                g_code.emit("LOADF " + Freg(r) + " " + Faddr() + " " + std::to_string(vb.offset));
                $$->reg = r;
            } else {
                semanticErrorFixed(SEM_ILLEGAL_VOID);
            }
        }
    | CALL { $$ = $1; }
    | NUM  { $$ = $1; }
    | '(' EXP ')' { $$ = $2; }
    | '(' TYPE ')' EXP %prec TK_CAST
        {
            const Type toT = $2->type;
            const Type fromT = $4->type;

            if (toT == void_t) {
                $$ = new Attr();
                $$->type = void_t;
                $$->reg = -1;
            } else {
                if (fromT == void_t) semanticErrorFixed(SEM_ILLEGAL_VOID);
                if (toT == fromT) $$ = $4;
                else if (toT == int_ && fromT == float_) {
                    $$ = new Attr();
                    $$->type = int_;
                    const int r = allocIntReg();
                    g_code.emit("CFTOI " + Ireg(r) + " " + Freg($4->reg));
                    $$->reg = r;
                } else if (toT == float_ && fromT == int_) {
                    $$ = new Attr();
                    $$->type = float_;
                    const int r = allocFloatReg();
                    g_code.emit("CITOF " + Freg(r) + " " + Ireg($4->reg));
                    $$->reg = r;
                } else {
                    semanticErrorFixed(SEM_TYPE_MISMATCH);
                }
            }
        }
    ;

NUM
    : TK_INTEGERNUM
        {
            $$ = $1;
            $$->type = int_;
            const int r = allocIntReg();
            g_code.emit("COPYI " + Ireg(r) + " " + $1->str);
            $$->reg = r;
        }
    | TK_REALNUM
        {
            $$ = $1;
            $$->type = float_;
            const int r = allocFloatReg();
            g_code.emit("COPYF " + Freg(r) + " " + $1->str);
            $$->reg = r;
        }
    ;

CALL
    : TK_ID '(' CALL_ARGS ')'
        {
            const string fname = $1->str;
            auto fit = g_functions.find(fname);
            if (fit == g_functions.end()) semanticErrorFixed(SEM_UNDECL_FUNC);

            const FunctionInfo& finfo = fit->second;
            const int nparams = static_cast<int>(finfo.paramTypes.size());

            const int npos = static_cast<int>($3->posTypes.size());
            if (npos > nparams) semanticErrorFixed(SEM_WRONG_NUM_ARGS);

            vector<bool> provided(static_cast<size_t>(nparams), false);
            vector<Type> argTypes(static_cast<size_t>(nparams), void_t);
            vector<int>  argRegs(static_cast<size_t>(nparams), -1);

            for (int i = 0; i < npos; ++i) {
                provided[i] = true;
                argTypes[i] = $3->posTypes[i];
                argRegs[i]  = $3->posRegs[i];
            }

            for (size_t j = 0; j < $3->namedNames.size(); ++j) {
                const string& label = $3->namedNames[j];

                int idx = -1;
                for (int k = 0; k < nparams; ++k) {
                    if (finfo.paramNames[k] == label) { idx = k; break; }
                }
                if (idx < 0) semanticErrorFixed(SEM_UNKNOWN_NAMED);
                if (idx < npos) semanticErrorFixed(SEM_PARAM_TWICE);
                if (provided[idx]) semanticErrorFixed(SEM_PARAM_TWICE);

                provided[idx] = true;
                argTypes[idx] = $3->namedTypes[j];
                argRegs[idx]  = $3->namedRegs[j];
            }

            for (int i = 0; i < nparams; ++i) {
                if (!provided[i]) semanticErrorFixed(SEM_WRONG_NUM_ARGS);
                if (argTypes[i] != finfo.paramTypes[i]) semanticErrorFixed(SEM_TYPE_MISMATCH);
            }

            // Save used temporaries (caller-saves)
            const int intTempsUsed   = g_nextIntReg   - INT_TMP_BASE;
            const int floatTempsUsed = g_nextFloatReg - FLOAT_TMP_BASE;
            const int saveSize = 4 * (intTempsUsed + floatTempsUsed);
            const int argSize  = 4 * nparams;

            if (saveSize > 0) {
                int offset = 0;
                for (int r = INT_TMP_BASE; r < g_nextIntReg; ++r) {
                    g_code.emit("STORI " + Ireg(r) + " I2 " + std::to_string(offset));
                    offset += 4;
                }
                if (floatTempsUsed > 0) {
                    addrToF0FromI("I2");
                    for (int r = FLOAT_TMP_BASE; r < g_nextFloatReg; ++r) {
                        g_code.emit("STORF " + Freg(r) + " " + Faddr() + " " + std::to_string(offset));
                        offset += 4;
                    }
                }
                g_code.emit("ADD2I I2 I2 " + std::to_string(saveSize));
            }

            // Push args (store at offsets, bump SP once)
            if (argSize > 0) {
                bool needFloatBase = false;
                for (int i = 0; i < nparams; ++i) {
                    if (finfo.paramTypes[i] == float_) { needFloatBase = true; break; }
                }
                if (needFloatBase) addrToF0FromI("I2");

                int offset = 0;
                for (int i = 0; i < nparams; ++i) {
                    if (finfo.paramTypes[i] == int_) {
                        g_code.emit("STORI " + Ireg(argRegs[i]) + " I2 " + std::to_string(offset));
                    } else {
                        g_code.emit("STORF " + Freg(argRegs[i]) + " " + Faddr() + " " + std::to_string(offset));
                    }
                    offset += 4;
                }
                g_code.emit("ADD2I I2 I2 " + std::to_string(argSize));
            }

            const int callLine = g_code.nextQuad();
            g_code.emit("JLINK ");
            g_functions[fname].callLines.push_back(callLine);

            if (finfo.isDefined) g_code.backpatch(vector<int>{callLine}, finfo.startLineImplementation);
            else g_functions[fname].unresolvedCallLines.push_back(callLine);

            // Pop args
            if (argSize > 0) g_code.emit("SUBTI I2 I2 " + std::to_string(argSize));

            // Restore temps
            if (saveSize > 0) {
                g_code.emit("SUBTI I4 I2 " + std::to_string(saveSize)); // I4 = base
                int offset = 0;
                for (int r = INT_TMP_BASE; r < g_nextIntReg; ++r) {
                    g_code.emit("LOADI " + Ireg(r) + " I4 " + std::to_string(offset));
                    offset += 4;
                }
                if (floatTempsUsed > 0) {
                    addrToF0FromI("I4");
                    for (int r = FLOAT_TMP_BASE; r < g_nextFloatReg; ++r) {
                        g_code.emit("LOADF " + Freg(r) + " " + Faddr() + " " + std::to_string(offset));
                        offset += 4;
                    }
                }
                g_code.emit("SUBTI I2 I2 " + std::to_string(saveSize));
            }

            $$ = new Attr();
            $$->type = finfo.returnType;

            if (finfo.returnType == int_) {
                const int r = allocIntReg();
                g_code.emit("COPYI " + Ireg(r) + " I3");
                $$->reg = r;
            } else if (finfo.returnType == float_) {
                const int r = allocFloatReg();
                g_code.emit("COPYF " + Freg(r) + " F3");
                $$->reg = r;
            } else {
                $$->reg = -1;
            }
        }
    ;

CALL_ARGS
    : /* empty */ { $$ = new Attr(); }
    | POS_ARGLIST { $$ = $1; }
    | NAMED_ARGLIST { $$ = $1; }
    | POS_ARGLIST ',' NAMED_ARGLIST
        {
            $$ = new Attr();
            $$->posTypes = $1->posTypes;
            $$->posRegs  = $1->posRegs;
            $$->namedNames = $3->namedNames;
            $$->namedTypes = $3->namedTypes;
            $$->namedRegs  = $3->namedRegs;
        }
    ;

POS_ARGLIST
    : EXP
        { $$ = new Attr(); $$->posTypes.push_back($1->type); $$->posRegs.push_back($1->reg); }
    | POS_ARGLIST ',' EXP
        { $$ = $1; $$->posTypes.push_back($3->type); $$->posRegs.push_back($3->reg); }
    ;

NAMED_ARGLIST
    : NAMED_ARG { $$ = $1; }
    | NAMED_ARGLIST ',' NAMED_ARG
        {
            $$ = $1;
            $$->namedNames.push_back($3->namedNames[0]);
            $$->namedTypes.push_back($3->namedTypes[0]);
            $$->namedRegs.push_back($3->namedRegs[0]);
        }
    ;

/* IMPORTANT FIX:
   Named args are parsed as label:value (ID ':' EXP)
   so calls like pack(y:2, x:1) work as expected. */
NAMED_ARG
    : TK_ID ':' EXP
        {
            $$ = new Attr();
            $$->namedNames.push_back($1->str); // label
            $$->namedTypes.push_back($3->type); // value type
            $$->namedRegs.push_back($3->reg);   // value reg
        }
    ;

%%

void yyerror(const char* /*s*/) {
    const string lexeme = (yytext != nullptr && yytext[0] != '\0') ? string(yytext) : string("EOF");
    cerr << "Syntax error: '" << lexeme << "' in line number " << yylineno << endl;
    std::exit(SYNTAX_ERROR);
}

static string replaceExtKeepPath(const string& path, const string& newExtWithDot) {
    const size_t slash = path.find_last_of("/\\");
    const size_t dot = path.find_last_of('.');
    if (dot == string::npos || (slash != string::npos && dot < slash)) return path + newExtWithDot;
    return path.substr(0, dot) + newExtWithDot;
}

int main(int argc, char** argv) {
    if (argc != 2) operationalError("usage: rx-cc <input_file.cmm>");

    const string inputFile = argv[1];
    if (inputFile.size() < 5 || inputFile.substr(inputFile.size() - 4) != ".cmm") {
        operationalError("input file must have .cmm extension");
    }

    yyin = std::fopen(inputFile.c_str(), "r");
    if (!yyin) operationalError("cannot open input file");

    yyparse();

    for (auto& kv : g_functions) {
        FunctionInfo& info = kv.second;
        if (!info.isDefined && !info.unresolvedCallLines.empty()) {
            g_code.backpatch(info.unresolvedCallLines, 0);
            info.unresolvedCallLines.clear();
        }
    }

    const string outputFile = replaceExtKeepPath(inputFile, ".rsk");
    std::ofstream out(outputFile);
    if (!out) operationalError("cannot open output file for writing");

    string unimpl = "<unimplemented>";
    string impl   = "<implemented>";

    for (const auto& kv : g_functions) {
        const string& fname = kv.first;
        const FunctionInfo& info = kv.second;

        if (info.isDefined) {
            impl += " " + fname + "," + std::to_string(info.startLineImplementation);
        } else {
            unimpl += " " + fname;
            for (int lineNo : info.callLines) unimpl += "," + std::to_string(lineNo);
        }
    }

    out << "<header>\n";
    out << unimpl << "\n";
    out << impl << "\n";
    out << "</header>\n";
    out << g_code.str();

    return 0;
}
