/*
 * EE046266 – Compilation Methods (Winter 2025–2026)
 * Project Part 3 – C-- → Riski compiler (rx-cc)
 *
 * This file is the Bison parser + code generator.
 *
 * High-level responsibilities:
 *  1) Parse C-- according to the project grammar.
 *  2) Enforce semantic rules (types, scoping, function API, named arguments).
 *  3) Emit Riski assembly to CodeBuffer, using backpatching for control-flow.
 *  4) Emit a 4-line linker header (<header> / <unimplemented> / <implemented> / </header>).
 *
 * Key implementation notes for “strangers”:
 *  - No global variables: each function has its own symbol table.
 *  - Static (lexical) scoping: inner blocks can shadow outer vars.
 *  - We generate code as we parse (single pass), using backpatch lists.
 *  - Calling convention is caller-saves: all temp registers may be clobbered by a call.
 *  - Riski has separate int and float register files. LOADF/STORF require a float base
 *    register; therefore we convert integer address registers (FP/SP) via CITOF into F0.
 */

%{
#include <cstdio>
#include <cstdlib>
#include <cstring>

#include <fstream>
#include <iostream>
#include <map>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <vector>

#include "part3_helpers.hpp"

using std::cerr;
using std::endl;
using std::string;
using std::vector;

extern int yylex(void);
extern int yylineno;
extern char* yytext;
extern FILE* yyin;

void yyerror(const char* s);

// -------------------- Global compiler state --------------------

/*
 * VarBinding:
 *  A variable is represented by (Type, offset) where offset is in bytes relative to FP (I1).
 *  - Locals are stored at positive offsets: FP+8, FP+12, ...
 *  - Parameters are stored at negative offsets, because FP points to the *end* of the args area.
 */
struct VarBinding {
    Type type;
    int offset; // bytes relative to FP
};

/*
 * FunctionInfo:
 *  Stored in g_functions for all declared/defined functions in this compilation unit.
 *  We keep:
 *   - return type + ordered parameter types + ordered parameter names
 *   - whether it is defined in THIS file, and if so its start line in the generated code
 *   - all call sites (for header output), and unresolved call sites (for backpatching)
 */
struct FunctionInfo {
    Type returnType = void_t;
    vector<Type> paramTypes;
    vector<string> paramNames;

    bool isDefined = false;
    int startLineImplementation = 0;

    vector<int> callLines;
    vector<int> unresolvedCallLines;
};

/*
 * g_code:
 *  The assembly we generate (Riski). Line numbers are 1-based as required by the VM/linker.
 *
 * g_functions:
 *  Function symbol table for this file, used both for semantic checks and for linker header.
 */
static CodeBuffer g_code;
static std::map<string, FunctionInfo> g_functions;

/*
 * Variable symbol table with static scoping:
 *  - g_scopes is a stack of scope-frames; each frame holds variable names declared in that scope.
 *  - g_vars maps name -> stack of bindings (to support shadowing). The top binding is the visible one.
 */
static std::unordered_map<string, vector<VarBinding>> g_vars;
static vector<std::unordered_set<string>> g_scopes;

/*
 * Per-function parsing/codegen context:
 *  - g_blockDepth tracks nested blocks; at depth 1 we insert function params into the symbol table.
 *  - g_currentReturnJumps is a list of UJUMP placeholders emitted for return statements;
 *    they get patched to the unified function epilogue.
 */
static int g_blockDepth = 0;
static bool g_paramsInserted = false;

static string g_currentFunc;
static Type g_currentReturnType = void_t;
static vector<Type> g_currentParamTypes;
static vector<string> g_currentParamNames;
static vector<int> g_currentReturnJumps;

/*
 * Temporary register allocation:
 *  We keep "reserved" low registers for calling convention / stack mgmt:
 *     I0 = return address (architectural)
 *     I1 = FP (frame pointer)
 *     I2 = SP (stack pointer)
 *     I3 / F3 = function return value (our convention)
 *     I4 = scratch (old FP / base for restore)
 *
 * Temps are allocated from INT_TMP_BASE / FLOAT_TMP_BASE upward.
 * We reset allocation between statements to keep temp usage bounded.
 */
static constexpr int INT_TMP_BASE   = 11;
static constexpr int FLOAT_TMP_BASE = 10;

/*
 * IMPORTANT: Riski has strict typing between int and float operands.
 * LOADF/STORF expect a FLOAT register as the base operand (B in Mem[B+C]).
 * Our stack pointers/FP are INT regs; therefore we convert I-base to float in F0.
 */
static constexpr int F_ADDR_SCRATCH = 0;

static int g_nextIntReg   = INT_TMP_BASE;
static int g_nextFloatReg = FLOAT_TMP_BASE;

/*
 * Stack-frame layout:
 *  We allocate a fixed 8-byte header at function entry:
 *    [FP + 0] old FP
 *    [FP + 4] saved return address (I0)
 *  Locals start at [FP + 8] and grow upward by 4 bytes each.
 *
 * g_nextLocalOffset tracks the next free local slot.
 * g_localAllocInstrLine is the line of "ADD2I I2 I2 <frameSize>" that we backpatch later.
 */
static int g_nextLocalOffset = 8;
static int g_localAllocInstrLine = -1;

// -------------------- Error helpers (canonical messages) --------------------

/*
 * The project requires printing to stderr and exiting with specific codes.
 * For semantic errors, the PDF says the description is free-form; however the provided
 * automated tests expect specific canonical phrases, so we use fixed strings below.
 */
[[noreturn]] static void semanticErrorFixed(const char* msg) {
    cerr << "Semantic error: " << msg << " in line number " << yylineno << endl;
    std::exit(SEMANTIC_ERROR);
}

[[noreturn]] static void operationalError(const string& msg) {
    cerr << "Operational error: " << msg << endl;
    std::exit(OPERATIONAL_ERROR);
}

// Canonical semantic messages expected by the tests:
static constexpr const char* SEM_DUP_PARAM_NAME   = "Duplicate parameter name";
static constexpr const char* SEM_UNDECL_VAR       = "Undeclared variable";
static constexpr const char* SEM_VAR_REDECL       = "Variable already declared";
static constexpr const char* SEM_FUNC_REDEF       = "Function redefined";
static constexpr const char* SEM_WRONG_NUM_ARGS   = "Wrong number of arguments";
static constexpr const char* SEM_UNKNOWN_NAMED    = "Unknown named parameter";
static constexpr const char* SEM_PARAM_TWICE      = "Parameter passed twice";
static constexpr const char* SEM_MUST_RET_VALUE   = "Must return value from non-void function";
static constexpr const char* SEM_CANT_RET_VALUE   = "Cannot return value from void function";

// Additional semantic errors not explicitly checked by “message-format” tests:
static constexpr const char* SEM_TYPE_MISMATCH    = "Type mismatch";
static constexpr const char* SEM_ILLEGAL_VOID     = "Illegal use of void";
static constexpr const char* SEM_UNDECL_FUNC      = "Undeclared function";

// -------------------- Small utilities --------------------

/* Convert register numbers to Riski register strings. */
static inline string Ireg(int r) { return "I" + std::to_string(r); }
static inline string Freg(int r) { return "F" + std::to_string(r); }

/* Address scratch register (float) used as base for LOADF/STORF. */
static inline string Faddr() { return Freg(F_ADDR_SCRATCH); }

/*
 * Convert integer address register → float address register in F0.
 * This is necessary because Riski enforces register-file types per opcode suffix:
 *  - LOADI/STORI: base in I
 *  - LOADF/STORF: base in F
 */
static inline void addrToF0FromI(const string& ibase) {
    g_code.emit("CITOF " + Faddr() + " " + ibase);
}

/* Reset temporary allocation between statements / control conditions. */
static inline void resetTemps() {
    g_nextIntReg = INT_TMP_BASE;
    g_nextFloatReg = FLOAT_TMP_BASE;
}

/* Allocate a fresh temp register index in the corresponding register file. */
static inline int allocIntReg()   { return g_nextIntReg++; }
static inline int allocFloatReg() { return g_nextFloatReg++; }

/* Utility to compare function APIs (no overloading allowed). */
static inline bool sameSignature(const FunctionInfo& a, const FunctionInfo& b) {
    return a.returnType == b.returnType &&
           a.paramTypes == b.paramTypes &&
           a.paramNames == b.paramNames;
}

/*
 * Variable lookup obeying static scoping:
 *  - If a name is unknown in the current function, it is a semantic error.
 */
static VarBinding lookupVar(const string& name) {
    auto it = g_vars.find(name);
    if (it == g_vars.end() || it->second.empty()) {
        semanticErrorFixed(SEM_UNDECL_VAR);
    }
    return it->second.back();
}

/* Check whether 'name' was already declared in the current (innermost) scope. */
static bool declaredInCurrentScope(const string& name) {
    if (g_scopes.empty()) return false;
    return g_scopes.back().find(name) != g_scopes.back().end();
}

/* Scope management: push/pop a lexical scope (BLK). */
static void pushScope() {
    g_scopes.emplace_back();
}

static void popScope() {
    if (g_scopes.empty()) return;

    /* Remove bindings introduced in the current scope (supports shadowing). */
    for (const auto& name : g_scopes.back()) {
        auto it = g_vars.find(name);
        if (it != g_vars.end() && !it->second.empty()) {
            it->second.pop_back();
            if (it->second.empty()) g_vars.erase(it);
        }
    }
    g_scopes.pop_back();
}

/*
 * Declare a variable in the current scope with a precomputed FP-relative offset.
 * Used for locals and for parameters (params have negative offsets).
 */
static void declareVarWithOffset(const string& name, Type t, int offset) {
    if (t == void_t) semanticErrorFixed(SEM_ILLEGAL_VOID);
    if (declaredInCurrentScope(name)) semanticErrorFixed(SEM_VAR_REDECL);

    g_scopes.back().insert(name);
    g_vars[name].push_back(VarBinding{t, offset});
}

/* Allocate one 4-byte local slot at FP+g_nextLocalOffset. */
static void declareLocal(const string& name, Type t) {
    const int offset = g_nextLocalOffset;
    g_nextLocalOffset += 4;
    declareVarWithOffset(name, t, offset);
}

/*
 * Insert function parameters into the *outermost* function block scope.
 * Convention:
 *   FP (I1) points to end-of-args area.
 *   With n params, param i is stored at:
 *     offset = -4*(n - i)
 */
static void insertParamsIntoCurrentScope() {
    if (g_paramsInserted) return;

    const int n = static_cast<int>(g_currentParamTypes.size());
    for (int i = 0; i < n; ++i) {
        const string& pname = g_currentParamNames[i];
        const Type ptype = g_currentParamTypes[i];

        if (ptype == void_t) semanticErrorFixed(SEM_ILLEGAL_VOID);

        const int offset = -4 * (n - i);
        declareVarWithOffset(pname, ptype, offset);
    }
    g_paramsInserted = true;
}

/*
 * Declare or define a function signature.
 * - Enforces: no overloading (same name must have identical API).
 * - Tracks whether the function is defined in this file.
 * - Does NOT enforce any special signature for "main":
 *   the PDF explicitly says wrong main signature is runtime-undefined, not a compile error.
 */
static void declareFunction(const string& name, Type retType,
                            const vector<Type>& paramTypes,
                            const vector<string>& paramNames,
                            bool isDefinition) {
    FunctionInfo sig;
    sig.returnType = retType;
    sig.paramTypes = paramTypes;
    sig.paramNames = paramNames;

    if (sig.paramTypes.size() != sig.paramNames.size()) {
        semanticErrorFixed(SEM_FUNC_REDEF);
    }

    /* Validate parameter names are unique and types are not void. */
    {
        std::unordered_set<string> seen;
        for (size_t i = 0; i < sig.paramNames.size(); ++i) {
            if (!seen.insert(sig.paramNames[i]).second) {
                semanticErrorFixed(SEM_DUP_PARAM_NAME);
            }
            if (sig.paramTypes[i] == void_t) {
                semanticErrorFixed(SEM_ILLEGAL_VOID);
            }
        }
    }

    auto it = g_functions.find(name);
    if (it == g_functions.end()) {
        FunctionInfo info = sig;
        info.isDefined = false;
        info.startLineImplementation = 0;
        g_functions.emplace(name, std::move(info));
        it = g_functions.find(name);
    } else {
        /* Function already seen: require identical signature and no redefinition. */
        FunctionInfo existingSig = it->second;
        existingSig.isDefined = false;
        existingSig.startLineImplementation = 0;
        existingSig.callLines.clear();
        existingSig.unresolvedCallLines.clear();

        if (!sameSignature(existingSig, sig)) {
            semanticErrorFixed(SEM_FUNC_REDEF);
        }
        if (isDefinition && it->second.isDefined) {
            semanticErrorFixed(SEM_FUNC_REDEF);
        }
    }

    if (isDefinition) it->second.isDefined = true;
}

/*
 * Begin emitting a function body:
 *  - sets current-function context and resets per-function symbol tables
 *  - patches calls to this function that appeared earlier in the file
 *  - emits prologue and a placeholder for allocating locals (patched in endFunction)
 */
static void beginFunction(const string& name) {
    auto it = g_functions.find(name);
    if (it == g_functions.end()) semanticErrorFixed(SEM_FUNC_REDEF);

    g_currentFunc = name;
    g_currentReturnType = it->second.returnType;
    g_currentParamTypes = it->second.paramTypes;
    g_currentParamNames = it->second.paramNames;

    /* New function ⇒ new variable environment. */
    g_vars.clear();
    g_scopes.clear();
    g_blockDepth = 0;
    g_paramsInserted = false;

    resetTemps();
    g_nextLocalOffset = 8;
    g_localAllocInstrLine = -1;
    g_currentReturnJumps.clear();

    /* Function "label" is the next emitted instruction line. */
    const int startLine = g_code.nextQuad();
    it->second.startLineImplementation = startLine;

    /* If we had calls before the definition, patch them now. */
    if (!it->second.unresolvedCallLines.empty()) {
        g_code.backpatch(it->second.unresolvedCallLines, startLine);
        it->second.unresolvedCallLines.clear();
    }

    /*
     * Prologue:
     *  I4 = old FP
     *  FP = SP (end-of-args)
     *  Save old FP and return address in frame header
     */
    g_code.emit("COPYI I4 I1");    // I4 = old FP
    g_code.emit("COPYI I1 I2");    // FP = SP (end-of-args)
    g_code.emit("STORI I4 I1 0");  // save old FP
    g_code.emit("STORI I0 I1 4");  // save return address

    /* Allocate header+locals (patched later with exact frame size). */
    g_localAllocInstrLine = g_code.nextQuad();
    g_code.emit("ADD2I I2 I2 ");
}

/*
 * End emitting a function body:
 *  - patch frame size allocation
 *  - patch all pending returns to the unified epilogue
 *  - emit epilogue and RETRN
 */
static void endFunction(const vector<int>& blkNextList) {
    const int frameSize = g_nextLocalOffset;
    g_code.backpatch(vector<int>{g_localAllocInstrLine}, frameSize);

    const int epilogueStart = g_code.nextQuad();
    g_code.backpatch(g_currentReturnJumps, epilogueStart);
    g_code.backpatch(blkNextList, epilogueStart);

    /* Epilogue: restore FP and return address, reset SP, and return. */
    g_code.emit("LOADI I4 I1 0");
    g_code.emit("LOADI I0 I1 4");
    g_code.emit("COPYI I2 I1");
    g_code.emit("COPYI I1 I4");
    g_code.emit("RETRN");

    /* Clear current-function context. */
    g_currentFunc.clear();
    g_currentReturnType = void_t;
    g_currentParamTypes.clear();
    g_currentParamNames.clear();
    g_currentReturnJumps.clear();
    g_blockDepth = 0;
    g_paramsInserted = false;
    resetTemps();
}

/*
 * Emit PRNTC sequence for a string literal, handling escape sequences:
 *   \n, \t, \", \\
 */
static void emitPrintString(const string& s) {
    for (size_t i = 0; i < s.size(); ++i) {
        unsigned char ch = static_cast<unsigned char>(s[i]);
        if (ch == '\\') {
            if (i + 1 >= s.size()) semanticErrorFixed(SEM_TYPE_MISMATCH);
            const char esc = s[i + 1];
            i++;
            switch (esc) {
                case 'n': ch = '\n'; break;
                case 't': ch = '\t'; break;
                case '"': ch = '"'; break;
                case '\\': ch = '\\'; break;
                default: semanticErrorFixed(SEM_TYPE_MISMATCH);
            }
        }
        g_code.emit("PRNTC " + std::to_string(static_cast<int>(ch)));
    }
}

%}

%code requires {
#include "part3_helpers.hpp"
}

%union { Attr* a; }

%token TK_INT TK_FLOAT TK_VOID
%token TK_IF TK_THEN TK_ELSE
%token TK_WHILE TK_DO
%token TK_READ TK_WRITE
%token TK_RETURN

%token TK_AND TK_OR TK_NOT
%token TK_ASSIGN

%token <a> TK_ID
%token <a> TK_INTEGERNUM TK_REALNUM
%token <a> TK_STR
%token <a> TK_RELOP TK_ADDOP TK_MULOP

%token TK_CAST

%type <a> PROGRAM FDEFS
%type <a> FUNC_DEC_API FUNC_DEF_API TYPE FUNC_ARGLIST DCL
%type <a> BLK BLK_BEGIN BLK_END STLIST STMT CNTRL IF_COND
%type <a> ASSN READ WRITE RETURN
%type <a> EXP NUM CALL CALL_ARGS POS_ARGLIST NAMED_ARGLIST NAMED_ARG
%type <a> LVAL
%type <a> BEXP M N

%left TK_OR
%left TK_AND
%left TK_RELOP
%left TK_ADDOP
%left TK_MULOP
%right TK_NOT
%right TK_CAST
%nonassoc IF_NO_ELSE
%nonassoc TK_ELSE

%%

/* PROGRAM ::= sequence of function declarations/definitions (possibly empty). */
PROGRAM
    : FDEFS
    ;

/*
 * FDEFS:
 *  We allow declarations and definitions in any order.
 *  For definitions, we call beginFunction() right after parsing the signature,
 *  then parse the BLK and close with endFunction().
 */
FDEFS
    : FDEFS FUNC_DEC_API
    | FDEFS FUNC_DEF_API { beginFunction($2->str); } BLK { endFunction($4->nextList); }
    | /* empty */ { $$ = new Attr(); }
    ;

/* Function declaration (prototype) ends with ';'. */
FUNC_DEC_API
    : TYPE TK_ID '(' ')' ';'
        { declareFunction($2->str, $1->type, {}, {}, false); $$ = new Attr(); }
    | TYPE TK_ID '(' FUNC_ARGLIST ')' ';'
        { declareFunction($2->str, $1->type, $4->paramTypes, $4->paramNames, false); $$ = new Attr(); }
    ;

/* Function definition signature (body comes after this rule). */
FUNC_DEF_API
    : TYPE TK_ID '(' ')'
        { declareFunction($2->str, $1->type, {}, {}, true); $$ = new Attr(); $$->str = $2->str; }
    | TYPE TK_ID '(' FUNC_ARGLIST ')'
        { declareFunction($2->str, $1->type, $4->paramTypes, $4->paramNames, true); $$ = new Attr(); $$->str = $2->str; }
    ;

TYPE
    : TK_INT   { $$ = new Attr(); $$->type = int_; }
    | TK_FLOAT { $$ = new Attr(); $$->type = float_; }
    | TK_VOID  { $$ = new Attr(); $$->type = void_t; }
    ;

/*
 * FUNC_ARGLIST builds ordered param lists.
 * Note: The grammar allows grouped declarations like a,b:int, which we expand
 * into two parameters with the same type.
 */
FUNC_ARGLIST
    : FUNC_ARGLIST ',' DCL
        {
            $$ = $1;
            for (size_t i = 0; i < $3->names.size(); ++i) {
                $$->paramNames.push_back($3->names[i]);
                $$->paramTypes.push_back($3->type);
            }
        }
    | DCL
        {
            $$ = new Attr();
            for (size_t i = 0; i < $1->names.size(); ++i) {
                $$->paramNames.push_back($1->names[i]);
                $$->paramTypes.push_back($1->type);
            }
        }
    ;

/* DCL supports grouped identifiers: x,y,z:int */
DCL
    : TK_ID ':' TYPE
        { $$ = new Attr(); $$->type = $3->type; $$->names.push_back($1->str); }
    | TK_ID ',' DCL
        { $$ = $3; $$->names.insert($$->names.begin(), $1->str); }
    ;

/*
 * BLK:
 *  Push a new scope when entering '{', pop it at '}'.
 *  The first (outermost) block of a function also gets the parameters inserted.
 */
BLK
    : '{' BLK_BEGIN STLIST '}' BLK_END { $$ = $3; }
    ;

BLK_BEGIN
    : /* empty */
        {
            pushScope();
            g_blockDepth++;
            if (g_blockDepth == 1) insertParamsIntoCurrentScope();
            $$ = new Attr();
        }
    ;

BLK_END
    : /* empty */
        {
            popScope();
            g_blockDepth--;
            $$ = new Attr();
        }
    ;

/*
 * STLIST:
 *  Classic backpatch pattern:
 *   - each statement may leave a "nextList" of pending jumps
 *   - marker M captures the next instruction line
 *   - previous nextList is backpatched to M.quad
 */
STLIST
    : STLIST M STMT
        {
            g_code.backpatch($1->nextList, $2->quad);
            $$ = new Attr();
            $$->nextList = $3->nextList;
        }
    | /* empty */ { $$ = new Attr(); }
    ;

/* Marker M: records nextQuad for control-flow backpatching. */
M
    : /* empty */ { $$ = new Attr(); $$->quad = g_code.nextQuad(); }
    ;

/* Marker N: emits an unconditional jump placeholder and returns it as nextList. */
N
    : /* empty */
        {
            $$ = new Attr();
            $$->nextList = vector<int>{g_code.nextQuad()};
            g_code.emit("UJUMP ");
        }
    ;

/*
 * STMT:
 *  Most statements reset temps afterward: since our register allocation is simple,
 *  this keeps temp usage bounded and makes calls safe with our caller-saves approach.
 */
STMT
    : DCL ';'
        {
            for (const auto& name : $1->names) declareLocal(name, $1->type);
            $$ = new Attr();
            resetTemps();
        }
    | ASSN { $$ = new Attr(); resetTemps(); }
    | EXP ';'
        {
            if ($1->type != void_t) semanticErrorFixed(SEM_TYPE_MISMATCH);
            $$ = new Attr();
            resetTemps();
        }
    | CNTRL { $$ = $1; resetTemps(); }
    | READ  { $$ = new Attr(); resetTemps(); }
    | WRITE { $$ = new Attr(); resetTemps(); }
    | RETURN { $$ = new Attr(); resetTemps(); }
    | BLK { $$ = $1; resetTemps(); }
    ;

/* Assignment: types must match; store according to type using FP-relative offset. */
ASSN
    : LVAL TK_ASSIGN EXP ';'
        {
            if ($1->type == void_t || $3->type == void_t) semanticErrorFixed(SEM_ILLEGAL_VOID);
            if ($1->type != $3->type) semanticErrorFixed(SEM_TYPE_MISMATCH);

            if ($1->type == int_) {
                g_code.emit("STORI " + Ireg($3->reg) + " I1 " + std::to_string($1->offset));
            } else {
                /* Float memory base must be float-register (convert FP to F0). */
                addrToF0FromI("I1");
                g_code.emit("STORF " + Freg($3->reg) + " " + Faddr() + " " + std::to_string($1->offset));
            }
            $$ = new Attr();
        }
    ;

LVAL
    : TK_ID
        {
            VarBinding vb = lookupVar($1->str);
            $$ = new Attr();
            $$->type = vb.type;
            $$->offset = vb.offset;
        }
    ;

READ
    : TK_READ '(' LVAL ')' ';'
        {
            if ($3->type == void_t) semanticErrorFixed(SEM_ILLEGAL_VOID);
            if ($3->type == int_) {
                const int r = allocIntReg();
                g_code.emit("READI " + Ireg(r));
                g_code.emit("STORI " + Ireg(r) + " I1 " + std::to_string($3->offset));
            } else {
                const int r = allocFloatReg();
                g_code.emit("READF " + Freg(r));
                addrToF0FromI("I1");
                g_code.emit("STORF " + Freg(r) + " " + Faddr() + " " + std::to_string($3->offset));
            }
            $$ = new Attr();
        }
    ;

WRITE
    : TK_WRITE '(' EXP ')' ';'
        {
            if ($3->type == int_) g_code.emit("PRNTI " + Ireg($3->reg));
            else if ($3->type == float_) g_code.emit("PRNTF " + Freg($3->reg));
            else semanticErrorFixed(SEM_TYPE_MISMATCH);
            $$ = new Attr();
        }
    | TK_WRITE '(' TK_STR ')' ';'
        { emitPrintString($3->str); $$ = new Attr(); }
    ;

/*
 * RETURN:
 *  - If returning a value, it must match the function return type.
 *  - We copy the return value to I3/F3 and jump to the function epilogue.
 *  - If there is no explicit return at the end of a non-void function, the PDF says
 *    we still must return; the value is undefined. Therefore endFunction always emits RETRN.
 */
RETURN
    : TK_RETURN EXP ';'
        {
            if (g_currentReturnType == void_t) semanticErrorFixed(SEM_CANT_RET_VALUE);
            if ($2->type != g_currentReturnType) semanticErrorFixed(SEM_TYPE_MISMATCH);

            if (g_currentReturnType == int_) g_code.emit("COPYI I3 " + Ireg($2->reg));
            else g_code.emit("COPYF F3 " + Freg($2->reg));

            const int j = g_code.nextQuad();
            g_code.emit("UJUMP ");
            g_currentReturnJumps.push_back(j);
            $$ = new Attr();
        }
    | TK_RETURN ';'
        {
            if (g_currentReturnType != void_t) semanticErrorFixed(SEM_MUST_RET_VALUE);
            const int j = g_code.nextQuad();
            g_code.emit("UJUMP ");
            g_currentReturnJumps.push_back(j);
            $$ = new Attr();
        }
    ;

/* IF_COND is a small helper so we can reset temps after evaluating the boolean. */
IF_COND
    : TK_IF BEXP { resetTemps(); $$ = $2; }
    ;

/*
 * Control statements:
 *  - if/then[/else] uses trueList/falseList backpatching.
 *  - while uses a loop-start marker + condition lists.
 */
CNTRL
    : IF_COND TK_THEN M STMT TK_ELSE N M STMT
        {
            g_code.backpatch($1->trueList, $3->quad);
            g_code.backpatch($1->falseList, $7->quad);

            $$ = new Attr();
            $$->nextList = mergeLists(mergeLists($4->nextList, $6->nextList), $8->nextList);
        }
    | IF_COND TK_THEN M STMT %prec IF_NO_ELSE
        {
            g_code.backpatch($1->trueList, $3->quad);
            $$ = new Attr();
            $$->nextList = mergeLists($1->falseList, $4->nextList);
        }
    | TK_WHILE M BEXP { resetTemps(); } TK_DO M STMT
        {
            g_code.backpatch($3->trueList, $6->quad);
            g_code.backpatch($7->nextList, $2->quad);
            g_code.emit("UJUMP " + std::to_string($2->quad));
            $$ = new Attr();
            $$->nextList = $3->falseList;
        }
    ;

/*
 * Boolean expressions:
 *  - OR/AND are short-circuit using backpatching.
 *  - Relational expression produces (trueList,falseList) using conditional branch.
 */
BEXP
    : BEXP TK_OR M BEXP
        {
            g_code.backpatch($1->falseList, $3->quad);
            $$ = new Attr();
            $$->trueList = mergeLists($1->trueList, $4->trueList);
            $$->falseList = $4->falseList;
        }
    | BEXP TK_AND M BEXP
        {
            g_code.backpatch($1->trueList, $3->quad);
            $$ = new Attr();
            $$->trueList = $4->trueList;
            $$->falseList = mergeLists($1->falseList, $4->falseList);
        }
    | TK_NOT BEXP
        { $$ = new Attr(); $$->trueList = $2->falseList; $$->falseList = $2->trueList; }
    | EXP TK_RELOP EXP
        {
            if ($1->type == void_t || $3->type == void_t) semanticErrorFixed(SEM_ILLEGAL_VOID);
            if ($1->type != $3->type) semanticErrorFixed(SEM_TYPE_MISMATCH);

            const string& op = $2->str;
            int condI = -1;

            /*
             * We compute a 0/1 condition result, then branch on it.
             * For floats: compare in float regs, then convert to int via CFTOI.
             */
            if ($1->type == int_) {
                condI = allocIntReg();
                if (op == "==")      g_code.emit("SEQUI " + Ireg(condI) + " " + Ireg($1->reg) + " " + Ireg($3->reg));
                else if (op == "<>") g_code.emit("SNEQI " + Ireg(condI) + " " + Ireg($1->reg) + " " + Ireg($3->reg));
                else if (op == "<")  g_code.emit("SLETI " + Ireg(condI) + " " + Ireg($1->reg) + " " + Ireg($3->reg));
                else if (op == ">")  g_code.emit("SGRTI " + Ireg(condI) + " " + Ireg($1->reg) + " " + Ireg($3->reg));
                else if (op == "<=") g_code.emit("SGRTI " + Ireg(condI) + " " + Ireg($1->reg) + " " + Ireg($3->reg));
                else if (op == ">=") g_code.emit("SLETI " + Ireg(condI) + " " + Ireg($1->reg) + " " + Ireg($3->reg));
                else semanticErrorFixed(SEM_TYPE_MISMATCH);
            } else {
                const int condF = allocFloatReg();
                if (op == "==")      g_code.emit("SEQUF " + Freg(condF) + " " + Freg($1->reg) + " " + Freg($3->reg));
                else if (op == "<>") g_code.emit("SNEQF " + Freg(condF) + " " + Freg($1->reg) + " " + Freg($3->reg));
                else if (op == "<")  g_code.emit("SLETF " + Freg(condF) + " " + Freg($1->reg) + " " + Freg($3->reg));
                else if (op == ">")  g_code.emit("SGRTF " + Freg(condF) + " " + Freg($1->reg) + " " + Freg($3->reg));
                else if (op == "<=") g_code.emit("SGRTF " + Freg(condF) + " " + Freg($1->reg) + " " + Freg($3->reg));
                else if (op == ">=") g_code.emit("SLETF " + Freg(condF) + " " + Freg($1->reg) + " " + Freg($3->reg));
                else semanticErrorFixed(SEM_TYPE_MISMATCH);

                condI = allocIntReg();
                g_code.emit("CFTOI " + Ireg(condI) + " " + Freg(condF));
            }

            /* For <= and >= we computed the opposite comparison, so "true" means cond==0. */
            const bool trueOnZero = (op == "<=" || op == ">=");

            $$ = new Attr();
            const int bline = g_code.nextQuad();
            if (trueOnZero) g_code.emit("BREQZ " + Ireg(condI) + " ");
            else            g_code.emit("BNEQZ " + Ireg(condI) + " ");
            $$->trueList.push_back(bline);

            const int jline = g_code.nextQuad();
            g_code.emit("UJUMP ");
            $$->falseList.push_back(jline);
        }
    | '(' BEXP ')'
        { $$ = $2; }
    ;

/*
 * Arithmetic/primary expressions:
 *  - Require matching types (unless explicit cast is used).
 *  - Variables load from memory (FP-relative).
 *  - Cast between int/float uses CITOF/CFTOI.
 */
EXP
    : EXP TK_ADDOP EXP
        {
            if ($1->type == void_t || $3->type == void_t) semanticErrorFixed(SEM_ILLEGAL_VOID);
            if ($1->type != $3->type) semanticErrorFixed(SEM_TYPE_MISMATCH);

            const string& op = $2->str;
            $$ = new Attr();
            $$->type = $1->type;

            if ($1->type == int_) {
                const int dst = $1->reg;
                if (op == "+") g_code.emit("ADD2I " + Ireg(dst) + " " + Ireg(dst) + " " + Ireg($3->reg));
                else if (op == "-") g_code.emit("SUBTI " + Ireg(dst) + " " + Ireg(dst) + " " + Ireg($3->reg));
                else semanticErrorFixed(SEM_TYPE_MISMATCH);
                $$->reg = dst;
            } else {
                const int dst = $1->reg;
                if (op == "+") g_code.emit("ADD2F " + Freg(dst) + " " + Freg(dst) + " " + Freg($3->reg));
                else if (op == "-") g_code.emit("SUBTF " + Freg(dst) + " " + Freg(dst) + " " + Freg($3->reg));
                else semanticErrorFixed(SEM_TYPE_MISMATCH);
                $$->reg = dst;
            }
        }
    | EXP TK_MULOP EXP
        {
            if ($1->type == void_t || $3->type == void_t) semanticErrorFixed(SEM_ILLEGAL_VOID);
            if ($1->type != $3->type) semanticErrorFixed(SEM_TYPE_MISMATCH);

            const string& op = $2->str;
            $$ = new Attr();
            $$->type = $1->type;

            if ($1->type == int_) {
                const int dst = $1->reg;
                if (op == "*") g_code.emit("MULTI " + Ireg(dst) + " " + Ireg(dst) + " " + Ireg($3->reg));
                else if (op == "/") g_code.emit("DIVDI " + Ireg(dst) + " " + Ireg(dst) + " " + Ireg($3->reg));
                else semanticErrorFixed(SEM_TYPE_MISMATCH);
                $$->reg = dst;
            } else {
                const int dst = $1->reg;
                if (op == "*") g_code.emit("MULTF " + Freg(dst) + " " + Freg(dst) + " " + Freg($3->reg));
                else if (op == "/") g_code.emit("DIVDF " + Freg(dst) + " " + Freg(dst) + " " + Freg($3->reg));
                else semanticErrorFixed(SEM_TYPE_MISMATCH);
                $$->reg = dst;
            }
        }
    | TK_ID
        {
            VarBinding vb = lookupVar($1->str);
            $$ = new Attr();
            $$->type = vb.type;
            $$->offset = vb.offset;

            if (vb.type == int_) {
                const int r = allocIntReg();
                g_code.emit("LOADI " + Ireg(r) + " I1 " + std::to_string(vb.offset));
                $$->reg = r;
            } else if (vb.type == float_) {
                const int r = allocFloatReg();
                addrToF0FromI("I1");
                g_code.emit("LOADF " + Freg(r) + " " + Faddr() + " " + std::to_string(vb.offset));
                $$->reg = r;
            } else {
                semanticErrorFixed(SEM_ILLEGAL_VOID);
            }
        }
    | CALL { $$ = $1; }
    | NUM  { $$ = $1; }
    | '(' EXP ')' { $$ = $2; }
    | '(' TYPE ')' EXP %prec TK_CAST
        {
            const Type toT = $2->type;
            const Type fromT = $4->type;

            if (toT == void_t) {
                $$ = new Attr();
                $$->type = void_t;
                $$->reg = -1;
            } else {
                if (fromT == void_t) semanticErrorFixed(SEM_ILLEGAL_VOID);
                if (toT == fromT) $$ = $4;
                else if (toT == int_ && fromT == float_) {
                    $$ = new Attr();
                    $$->type = int_;
                    const int r = allocIntReg();
                    g_code.emit("CFTOI " + Ireg(r) + " " + Freg($4->reg));
                    $$->reg = r;
                } else if (toT == float_ && fromT == int_) {
                    $$ = new Attr();
                    $$->type = float_;
                    const int r = allocFloatReg();
                    g_code.emit("CITOF " + Freg(r) + " " + Ireg($4->reg));
                    $$->reg = r;
                } else {
                    semanticErrorFixed(SEM_TYPE_MISMATCH);
                }
            }
        }
    ;

/* Numeric literals: emit COPYI/COPYF into a fresh temp. */
NUM
    : TK_INTEGERNUM
        {
            $$ = $1;
            $$->type = int_;
            const int r = allocIntReg();
            g_code.emit("COPYI " + Ireg(r) + " " + $1->str);
            $$->reg = r;
        }
    | TK_REALNUM
        {
            $$ = $1;
            $$->type = float_;
            const int r = allocFloatReg();
            g_code.emit("COPYF " + Freg(r) + " " + $1->str);
            $$->reg = r;
        }
    ;

/*
 * CALL:
 *  Semantic checks:
 *   - function must be declared before use (in this file)
 *   - argument count and types must match
 *   - named args map by parameter name, and cannot be duplicated
 *
 *  Codegen (calling convention):
 *   1) Save currently-used temp registers on stack (caller-saves).
 *   2) Push arguments to stack in *parameter order* (after mapping).
 *   3) JLINK to callee label (patched if unknown yet).
 *   4) Pop args, restore temps, and copy return value from I3/F3 if non-void.
 */
CALL
    : TK_ID '(' CALL_ARGS ')'
        {
            const string fname = $1->str;
            auto fit = g_functions.find(fname);
            if (fit == g_functions.end()) semanticErrorFixed(SEM_UNDECL_FUNC);

            const FunctionInfo& finfo = fit->second;
            const int nparams = static_cast<int>(finfo.paramTypes.size());

            const int npos = static_cast<int>($3->posTypes.size());
            if (npos > nparams) semanticErrorFixed(SEM_WRONG_NUM_ARGS);

            vector<bool> provided(static_cast<size_t>(nparams), false);
            vector<Type> argTypes(static_cast<size_t>(nparams), void_t);
            vector<int>  argRegs(static_cast<size_t>(nparams), -1);

            /* First fill positional arguments in order. */
            for (int i = 0; i < npos; ++i) {
                provided[i] = true;
                argTypes[i] = $3->posTypes[i];
                argRegs[i]  = $3->posRegs[i];
            }

            /* Then process named arguments (must not collide with earlier ones). */
            for (size_t j = 0; j < $3->namedNames.size(); ++j) {
                const string& label = $3->namedNames[j];

                int idx = -1;
                for (int k = 0; k < nparams; ++k) {
                    if (finfo.paramNames[k] == label) { idx = k; break; }
                }
                if (idx < 0) semanticErrorFixed(SEM_UNKNOWN_NAMED);
                if (idx < npos) semanticErrorFixed(SEM_PARAM_TWICE);
                if (provided[idx]) semanticErrorFixed(SEM_PARAM_TWICE);

                provided[idx] = true;
                argTypes[idx] = $3->namedTypes[j];
                argRegs[idx]  = $3->namedRegs[j];
            }

            /* Ensure all parameters are provided and types match. */
            for (int i = 0; i < nparams; ++i) {
                if (!provided[i]) semanticErrorFixed(SEM_WRONG_NUM_ARGS);
                if (argTypes[i] != finfo.paramTypes[i]) semanticErrorFixed(SEM_TYPE_MISMATCH);
            }

            // Save used temporaries (caller-saves)
            const int intTempsUsed   = g_nextIntReg   - INT_TMP_BASE;
            const int floatTempsUsed = g_nextFloatReg - FLOAT_TMP_BASE;
            const int saveSize = 4 * (intTempsUsed + floatTempsUsed);
            const int argSize  = 4 * nparams;

            if (saveSize > 0) {
                int offset = 0;
                for (int r = INT_TMP_BASE; r < g_nextIntReg; ++r) {
                    g_code.emit("STORI " + Ireg(r) + " I2 " + std::to_string(offset));
                    offset += 4;
                }
                if (floatTempsUsed > 0) {
                    addrToF0FromI("I2");
                    for (int r = FLOAT_TMP_BASE; r < g_nextFloatReg; ++r) {
                        g_code.emit("STORF " + Freg(r) + " " + Faddr() + " " + std::to_string(offset));
                        offset += 4;
                    }
                }
                g_code.emit("ADD2I I2 I2 " + std::to_string(saveSize));
            }

            // Push args (store at offsets, bump SP once)
            if (argSize > 0) {
                bool needFloatBase = false;
                for (int i = 0; i < nparams; ++i) {
                    if (finfo.paramTypes[i] == float_) { needFloatBase = true; break; }
                }
                if (needFloatBase) addrToF0FromI("I2");

                int offset = 0;
                for (int i = 0; i < nparams; ++i) {
                    if (finfo.paramTypes[i] == int_) {
                        g_code.emit("STORI " + Ireg(argRegs[i]) + " I2 " + std::to_string(offset));
                    } else {
                        g_code.emit("STORF " + Freg(argRegs[i]) + " " + Faddr() + " " + std::to_string(offset));
                    }
                    offset += 4;
                }
                g_code.emit("ADD2I I2 I2 " + std::to_string(argSize));
            }

            const int callLine = g_code.nextQuad();
            g_code.emit("JLINK ");
            g_functions[fname].callLines.push_back(callLine);

            if (finfo.isDefined) g_code.backpatch(vector<int>{callLine}, finfo.startLineImplementation);
            else g_functions[fname].unresolvedCallLines.push_back(callLine);

            // Pop args
            if (argSize > 0) g_code.emit("SUBTI I2 I2 " + std::to_string(argSize));

            // Restore temps
            if (saveSize > 0) {
                g_code.emit("SUBTI I4 I2 " + std::to_string(saveSize)); // I4 = base
                int offset = 0;
                for (int r = INT_TMP_BASE; r < g_nextIntReg; ++r) {
                    g_code.emit("LOADI " + Ireg(r) + " I4 " + std::to_string(offset));
                    offset += 4;
                }
                if (floatTempsUsed > 0) {
                    addrToF0FromI("I4");
                    for (int r = FLOAT_TMP_BASE; r < g_nextFloatReg; ++r) {
                        g_code.emit("LOADF " + Freg(r) + " " + Faddr() + " " + std::to_string(offset));
                        offset += 4;
                    }
                }
                g_code.emit("SUBTI I2 I2 " + std::to_string(saveSize));
            }

            $$ = new Attr();
            $$->type = finfo.returnType;

            if (finfo.returnType == int_) {
                const int r = allocIntReg();
                g_code.emit("COPYI " + Ireg(r) + " I3");
                $$->reg = r;
            } else if (finfo.returnType == float_) {
                const int r = allocFloatReg();
                g_code.emit("COPYF " + Freg(r) + " F3");
                $$->reg = r;
            } else {
                $$->reg = -1;
            }
        }
    ;

/*
 * CALL_ARGS:
 *  Grammar enforces "positional first, named after" by only allowing:
 *    - empty
 *    - POS_ARGLIST
 *    - NAMED_ARGLIST
 *    - POS_ARGLIST ',' NAMED_ARGLIST
 */
CALL_ARGS
    : /* empty */ { $$ = new Attr(); }
    | POS_ARGLIST { $$ = $1; }
    | NAMED_ARGLIST { $$ = $1; }
    | POS_ARGLIST ',' NAMED_ARGLIST
        {
            $$ = new Attr();
            $$->posTypes = $1->posTypes;
            $$->posRegs  = $1->posRegs;
            $$->namedNames = $3->namedNames;
            $$->namedTypes = $3->namedTypes;
            $$->namedRegs  = $3->namedRegs;
        }
    ;

POS_ARGLIST
    : EXP
        { $$ = new Attr(); $$->posTypes.push_back($1->type); $$->posRegs.push_back($1->reg); }
    | POS_ARGLIST ',' EXP
        { $$ = $1; $$->posTypes.push_back($3->type); $$->posRegs.push_back($3->reg); }
    ;

NAMED_ARGLIST
    : NAMED_ARG { $$ = $1; }
    | NAMED_ARGLIST ',' NAMED_ARG
        {
            $$ = $1;
            $$->namedNames.push_back($3->namedNames[0]);
            $$->namedTypes.push_back($3->namedTypes[0]);
            $$->namedRegs.push_back($3->namedRegs[0]);
        }
    ;

/*
 * Named argument syntax in this implementation:
 *   label : value
 * Example:
 *   f(b:2, a:1)
 */
NAMED_ARG
    : TK_ID ':' EXP
        {
            $$ = new Attr();
            $$->namedNames.push_back($1->str); // label
            $$->namedTypes.push_back($3->type); // value type
            $$->namedRegs.push_back($3->reg);   // value reg
        }
    ;

%%

/*
 * Syntax error handler:
 *  The required message format is:
 *    Syntax error: '<lexeme>' in line number <line>
 *  where <lexeme> is the current token text (or "EOF").
 */
void yyerror(const char* /*s*/) {
    const string lexeme = (yytext != nullptr && yytext[0] != '\0') ? string(yytext) : string("EOF");
    cerr << "Syntax error: '" << lexeme << "' in line number " << yylineno << endl;
    std::exit(SYNTAX_ERROR);
}

/* Replace extension while preserving directory path (dir/a.cmm → dir/a.rsk). */
static string replaceExtKeepPath(const string& path, const string& newExtWithDot) {
    const size_t slash = path.find_last_of("/\\");
    const size_t dot = path.find_last_of('.');
    if (dot == string::npos || (slash != string::npos && dot < slash)) return path + newExtWithDot;
    return path.substr(0, dot) + newExtWithDot;
}

int main(int argc, char** argv) {
    if (argc != 2) operationalError("usage: rx-cc <input_file.cmm>");

    const string inputFile = argv[1];
    if (inputFile.size() < 5 || inputFile.substr(inputFile.size() - 4) != ".cmm") {
        operationalError("input file must have .cmm extension");
    }

    yyin = std::fopen(inputFile.c_str(), "r");
    if (!yyin) operationalError("cannot open input file");

    yyparse();

    /*
     * Any call sites still unresolved by end-of-file point to a function implemented
     * in another module. The linker will patch these; we write a placeholder target (0).
     */
    for (auto& kv : g_functions) {
        FunctionInfo& info = kv.second;
        if (!info.isDefined && !info.unresolvedCallLines.empty()) {
            g_code.backpatch(info.unresolvedCallLines, 0);
            info.unresolvedCallLines.clear();
        }
    }

    const string outputFile = replaceExtKeepPath(inputFile, ".rsk");
    std::ofstream out(outputFile);
    if (!out) operationalError("cannot open output file for writing");

    /*
     * Linker header format:
     *  <header>
     *  <unimplemented> func,L1,L2... func2,L1...
     *  <implemented>   func,L   func2,L...
     *  </header>
     *
     * NOTE: All line numbers refer to the code *after* </header>, starting from 1.
     */
    string unimpl = "<unimplemented>";
    string impl   = "<implemented>";

    for (const auto& kv : g_functions) {
        const string& fname = kv.first;
        const FunctionInfo& info = kv.second;

        if (info.isDefined) {
            impl += " " + fname + "," + std::to_string(info.startLineImplementation);
        } else {
            unimpl += " " + fname;
            for (int lineNo : info.callLines) unimpl += "," + std::to_string(lineNo);
        }
    }

    out << "<header>\n";
    out << unimpl << "\n";
    out << impl << "\n";
    out << "</header>\n";
    out << g_code.str();

    return 0;
}
